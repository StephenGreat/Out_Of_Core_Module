\section{test\-Reading\-Disk\-Image.\-cpp}
Showing how to use the \doxyref{Disk\-Big\-Image}{p.}{class_disk_big_image} class. This an example of how to read the image data from the big image that stored in the file system.


\begin{DoxyCodeInclude}
\textcolor{preprocessor}{#include "../src/DiskBigImage.hpp"}

\textcolor{preprocessor}{#include <opencv2/core/core.hpp>}
\textcolor{preprocessor}{#include <opencv2/highgui/highgui.hpp>}
\textcolor{preprocessor}{#include <opencv2/imgproc/imgproc.hpp>}

\textcolor{preprocessor}{#include <iostream>}
\textcolor{preprocessor}{#include <string>}

\textcolor{comment}{/*}
\textcolor{comment}{ * test the correctness of reading a big image from disk that was wrote by
       BlockwiseImage or HierarchicalImage}
\textcolor{comment}{ * input the (*.bigimage) file name, then get the range image data}
\textcolor{comment}{ */}

\textcolor{keywordtype}{bool} test\_read\_level\_range\_image(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)
\{
        \textcolor{keyword}{using namespace }std;
        \textcolor{keywordflow}{if}(argc < 2) \{
                cout << \textcolor{stringliteral}{"Input the big image file name to get level data"} << 
      endl;
                cout << \textcolor{stringliteral}{"Usage : [image file name] "} << endl;
                \textcolor{keywordflow}{return} \textcolor{keyword}{false};
        \}

        \textcolor{keyword}{const} \textcolor{keywordtype}{char} *file\_name = argv[1];
        boost::shared\_ptr<DiskBigImageInterface<Vec3b> > big\_image = 
      load\_disk\_image<Vec3b>(file\_name); 
        \textcolor{keywordflow}{if}(!big\_image) \{
                cerr << \textcolor{stringliteral}{"can't load image "} << endl;
                \textcolor{keywordflow}{return} \textcolor{keyword}{false};
        \}

        \textcolor{comment}{/* save the input para */}
        std::string str\_array[5];
        \textcolor{keywordflow}{while}(1) \{
                cout << \textcolor{stringliteral}{"Input (quit to exit) : [image level] [start\_row]
       [start\_col] [rows] [cols]"} << endl;

                cin >> str\_array[0];
                \textcolor{keywordflow}{if}(str\_array[0] == \textcolor{stringliteral}{"quit"})      \textcolor{keywordflow}{return} \textcolor{keyword}{true};

                cin >> str\_array[1] >> str\_array[2] >> str\_array[3] >> 
      str\_array[4];

                \textcolor{keywordtype}{int} level = atoi(str\_array[0].c\_str());
                \textcolor{keywordtype}{int} start\_row = atoi(str\_array[1].c\_str());
                \textcolor{keywordtype}{int} start\_col = atoi(str\_array[2].c\_str());
                \textcolor{keywordtype}{int} rows = atoi(str\_array[3].c\_str());
                \textcolor{keywordtype}{int} cols = atoi(str\_array[4].c\_str());

                \textcolor{keywordflow}{if}(!big\_image->set\_current\_level(level)) \textcolor{keywordflow}{continue};

                cout << \textcolor{stringliteral}{"The level image size is "} << \textcolor{stringliteral}{"("}
                        << big\_image->get\_current\_level\_image\_rows() << \textcolor{stringliteral}{","} 
                        << big\_image->get\_current\_level\_image\_cols() << \textcolor{stringliteral}{")"} << 
      endl;

                \textcolor{keywordflow}{try}\{
                        std::vector<Vec3b> vec;
                        \textcolor{keywordflow}{if}(!big\_image->get\_pixels\_by\_level(level, start\_row, 
      start\_col, rows, cols, vec))
                                \textcolor{keywordflow}{continue};

                        cv::Mat result\_image(rows, cols, CV\_8UC3, vec.data());

                        \textcolor{comment}{/* image data was wrote in the format of RGB, but
       opencv is BRG*/}
                        cv::cvtColor(result\_image, result\_image, CV\_RGB2BGR);
                        cv::namedWindow(\textcolor{stringliteral}{"get pixel by level image"});
                        cv::imshow(\textcolor{stringliteral}{"get pixel by level image"}, result\_image);
                        cv::waitKey(2000);

                \} \textcolor{keywordflow}{catch}(std::exception &err) \{
                        cout << err.what() << endl;
                        \textcolor{keywordflow}{return} \textcolor{keyword}{false};
                \}
        \}

        \textcolor{keywordflow}{return} \textcolor{keyword}{true};
\}
\end{DoxyCodeInclude}
 