\section{Blockwise\-Image.\-hpp}
\label{_blockwise_image_8hpp}\index{D\-:/\-Out\-\_\-\-Of\-\_\-\-Core\-\_\-\-Git/src/\-Blockwise\-Image.\-hpp@{D\-:/\-Out\-\_\-\-Of\-\_\-\-Core\-\_\-\-Git/src/\-Blockwise\-Image.\-hpp}}

\begin{DoxyCode}
00001 \textcolor{preprocessor}{#ifndef \_BLOCKWISE\_IMAGE\_HPP}
00002 \textcolor{preprocessor}{}\textcolor{preprocessor}{#define \_BLOCKWISE\_IMAGE\_HPP}
00003 \textcolor{preprocessor}{}
00004 \textcolor{preprocessor}{#include "BlockwiseImage.h"}
00005 \textcolor{preprocessor}{#include "IndexMethod.hpp"}
00006 
00007 \textcolor{preprocessor}{#include <boost/assert.hpp>}
00008 \textcolor{preprocessor}{#include <boost/lexical\_cast.hpp>}
00009 
00010 \textcolor{preprocessor}{#include <string>}
00011 \textcolor{preprocessor}{#include <fstream>}
00012 \textcolor{preprocessor}{#include <strstream>}
00013 
00014 \textcolor{preprocessor}{#ifdef SAVE\_MINI\_IMAGE}
00015 \textcolor{preprocessor}{}\textcolor{comment}{/*---------------------------------------------*/}
00016 \textcolor{comment}{/* opencv part */}
00017 \textcolor{preprocessor}{#include <opencv2/core/core.hpp>}
00018 \textcolor{preprocessor}{#include <opencv2/highgui/highgui.hpp>}
00019 \textcolor{preprocessor}{#include <opencv2/imgproc/imgproc.hpp>}
00020 
00021 \textcolor{preprocessor}{#ifdef NDEBUG}
00022 \textcolor{preprocessor}{}\textcolor{preprocessor}{#pragma comment(lib, "opencv\_highgui240.lib")}
00023 \textcolor{preprocessor}{}\textcolor{preprocessor}{#pragma comment(lib, "opencv\_core240.lib")}
00024 \textcolor{preprocessor}{}\textcolor{preprocessor}{#pragma comment(lib, "opencv\_imgproc240.lib")}
00025 \textcolor{preprocessor}{}\textcolor{preprocessor}{#else}
00026 \textcolor{preprocessor}{}\textcolor{preprocessor}{#pragma comment(lib, "opencv\_highgui240d.lib")}
00027 \textcolor{preprocessor}{}\textcolor{preprocessor}{#pragma comment(lib, "opencv\_core240d.lib")}
00028 \textcolor{preprocessor}{}\textcolor{preprocessor}{#pragma comment(lib, "opencv\_imgproc240d.lib")}
00029 \textcolor{preprocessor}{}\textcolor{preprocessor}{#endif}
00030 \textcolor{preprocessor}{}\textcolor{comment}{/*---------------------------------------------*/}
00031 \textcolor{preprocessor}{#endif}
00032 \textcolor{preprocessor}{}
00033 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{unsigned} memory\_usage>
00034 BlockwiseImage<T, memory_usage>::BlockwiseImage(\textcolor{keywordtype}{int} rows, \textcolor{keywordtype}{int} cols, \textcolor{keywordtype}{int} 
      mini\_rows, \textcolor{keywordtype}{int} mini\_cols, 
00035         boost::shared\_ptr<IndexMethodInterface> method)
00036         : GiantImageInterface(method ? method : (boost::shared\_ptr<
      IndexMethodInterface>(new ZOrderIndex(rows, cols))))
00037 \{
00038         init(rows, cols);
00039         set_minimal_resolution(rows, cols, mini\_rows, mini\_cols);
00040 \}
00041 
00042 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{unsigned} memory\_usage>
00043 \textcolor{keywordtype}{bool} BlockwiseImage<T, memory_usage>::reset()
00044 \{
00045         init(0, 0);
00046         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00047 \}
00048 
00049 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{unsigned} memory\_usage>
00050 \textcolor{keywordtype}{bool} BlockwiseImage<T, memory_usage>::init(\textcolor{keywordtype}{int} rows, \textcolor{keywordtype}{int} cols)
00051 \{
00052         BOOST\_ASSERT(rows >= 0 && cols >= 0);
00053 
00054         \textcolor{comment}{/* ensure index\_method is valid */}
00055         BOOST\_ASSERT(index\_method.use\_count() != 0);
00056 
00057         img\_size.rows = rows;
00058         img\_size.cols = cols;
00059 
00060         img\_container.resize(index\_method->get\_max\_index() + 1);
00061         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00062 \}
00063 
00064 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{unsigned} memory\_usage>
00065 \textcolor{keywordtype}{void} BlockwiseImage<T, memory_usage>::set_minimal_resolution(\textcolor{keywordtype}{int} rows, \textcolor{keywordtype}{int} cols
      , \textcolor{keywordtype}{int} mini\_rows, \textcolor{keywordtype}{int} mini\_cols)
00066 \{
00067         BOOST\_ASSERT(m\_mini\_rows >= 0 && m\_mini\_cols >= 0 && rows >= mini\_rows 
      && cols >= mini\_cols);
00068 
00069         \textcolor{comment}{/* ensure the mini\_rows and mini\_cols not zero to insure the
       correctness of the division */}
00070         \textcolor{keywordflow}{if}(mini\_rows == 0)      mini\_rows = 1;
00071         \textcolor{keywordflow}{if}(mini\_cols == 0)      mini\_cols = 1;
00072 
00073         \textcolor{keywordtype}{size\_t} level\_row = rows / mini\_rows, level\_col = cols / mini\_cols;
00074         level\_row = get\_least\_order\_number(level\_row);
00075         level\_col = get\_least\_order\_number(level\_col);
00076 
00077         \textcolor{comment}{/* ensure the smallest image (the max scale level) is not less than
       mini\_rows or mini\_cols which user specified */}
00078         m\_max\_level = (level\_row < level\_col) ? level\_row : level\_col;
00079 
00080         \textcolor{comment}{/* recalculate the mini\_rows and mini\_cols */}
00081         m\_mini\_rows = std::ceil((\textcolor{keywordtype}{double})(rows) / (1 << m\_max\_level));
00082         m\_mini\_cols = std::ceil((\textcolor{keywordtype}{double})(cols) / (1 << m\_max\_level));
00083 \}
00084 
00085 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{unsigned} memory\_usage>
00086 BlockwiseImage<T, memory_usage>::~BlockwiseImage()
00087 \{
00088         img\_container.clear();
00089 \}
00090 
00091 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{unsigned} memory\_usage>
00092 \textcolor{keywordtype}{bool} BlockwiseImage<T, memory_usage>::set_pixels(\textcolor{keywordtype}{int} start\_row, \textcolor{keywordtype}{int} start\_col, \textcolor{keywordtype}{
      int} rows, \textcolor{keywordtype}{int} cols, \textcolor{keyword}{const} std::vector<T> &data)
00093 \{
00094         \textcolor{keywordflow}{if}(start\_row < 0 || start\_col < 0 || start\_row > (get\_image\_rows()-1) 
      || start\_col > (get\_image\_cols()-1)
00095                 || rows <= 0 || cols <= 0 || (start\_row+rows) > get\_image\_rows(
      ) || (start\_col+cols) > get\_image\_cols()) \{
00096                         std::cerr << \textcolor{stringliteral}{"BlockwiseImage::set\_pixels error :
       Invalid parameter"} << std::endl;
00097                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00098         \}
00099 
00100         \textcolor{keywordflow}{if}(data.size() < (rows*cols))   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00101 
00102         \textcolor{keywordtype}{size\_t} count = 0;
00103         \textcolor{keywordflow}{for}(IndexMethodInterface::RowMajorIndexType row = 0; row < rows; ++row)
       \{
00104                 IndexMethodInterface::IndexType row\_result = index\_method->
      get\_row\_result(start\_row+row);
00105                 \textcolor{keywordflow}{for}(IndexMethodInterface::RowMajorIndexType col = 0; col < cols
      ; ++col) \{
00106                         img\_container[index\_method->get\_index\_by\_row\_result(
      row\_result, start\_col+col)] = data[count++];
00107                 \}
00108         \}
00109         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00110 \}
00111 
00112 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{unsigned} memory\_usage>
00113 \textcolor{keywordtype}{bool} BlockwiseImage<T, memory_usage>::get_pixels(\textcolor{keywordtype}{int} start\_row, \textcolor{keywordtype}{int} start\_col, \textcolor{keywordtype}{
      int} rows, \textcolor{keywordtype}{int} cols, std::vector<T> &data)\textcolor{keyword}{ const}
00114 \textcolor{keyword}{}\{
00115         \textcolor{keywordflow}{if}(start\_row < 0 || start\_col < 0 || start\_row > (get\_image\_rows()-1) 
      || start\_col > (get\_image\_cols()-1)
00116                 || rows <= 0 || cols <= 0 || (start\_row+rows) > get\_image\_rows(
      ) || (start\_col+cols) > get\_image\_cols()) \{
00117                         std::cerr << \textcolor{stringliteral}{"BlockwiseImage::get\_pixels error :
       Invalid parameter"} << std::endl;
00118                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00119         \}
00120 
00121         data.resize(rows*cols);
00122 
00123         \textcolor{keyword}{static} \textcolor{keyword}{const} ContainerType &c\_img\_container = img\_container;
00124         \textcolor{keywordtype}{size\_t} count = 0;
00125         \textcolor{keywordflow}{for}(IndexMethodInterface::RowMajorIndexType row = 0; row < rows; ++row)
       \{
00126                 IndexMethodInterface::IndexType row\_result = index\_method->
      get\_row\_result(start\_row+row);
00127                 \textcolor{keywordflow}{for}(IndexMethodInterface::RowMajorIndexType col = 0; col < cols
      ; ++col) \{
00128                         data[count++] = c\_img\_container[index\_method->
      get\_index\_by\_row\_result(row\_result, start\_col+col)];
00129                 \}
00130         \}
00131         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00132 \}
00133 
00134 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{unsigned} memory\_usage>
00135 \textcolor{keywordtype}{bool} BlockwiseImage<T, memory_usage>::set_pixels(\textcolor{keywordtype}{int} start\_row, \textcolor{keywordtype}{int} start\_col, \textcolor{keywordtype}{
      int} rows, \textcolor{keywordtype}{int} cols, \textcolor{keyword}{const} T clear\_value)
00136 \{
00137         \textcolor{keywordflow}{if}(start\_row < 0 || start\_col < 0 || start\_row > (get\_image\_rows()-1) 
      || start\_col > (get\_image\_cols()-1)
00138                 || rows <= 0 || cols <= 0 || (start\_row+rows) > get\_image\_rows(
      ) || (start\_col+cols) > get\_image\_cols()) \{
00139                         std::cerr << \textcolor{stringliteral}{"BlockwiseImage::set\_pixels error :
       Invalid parameter"} << std::endl;
00140                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00141         \}
00142 
00143         \textcolor{keywordflow}{for}(IndexMethodInterface::RowMajorIndexType row = 0; row < rows; ++row)
       \{
00144                 IndexMethodInterface::IndexType row\_result = index\_method->
      get\_row\_result(start\_row+row);
00145                 \textcolor{keywordflow}{for}(IndexMethodInterface::RowMajorIndexType col = 0; col < cols
      ; ++col) \{
00146                         img\_container[index\_method->get\_index\_by\_row\_result(
      row\_result, start\_col+col)] = clear\_value;
00147                 \}
00148         \}
00149         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00150 \}
00151 
00152 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{unsigned} memory\_usage>
00153 \textcolor{keyword}{const} T& BlockwiseImage<T, memory_usage>::operator()(\textcolor{keywordtype}{int} row, \textcolor{keywordtype}{int} col)\textcolor{keyword}{ const}
00154 \textcolor{keyword}{}\{
00155         BOOST\_ASSERT(0 <= row && row < img\_size.rows && 0 <= col && col < 
      img\_size.cols);
00156         \textcolor{keyword}{static} \textcolor{keyword}{const} ContainerType &c\_img\_container = img\_container;
00157         \textcolor{keywordflow}{return} c\_img\_container[index\_method->get\_index(row, col)];
00158 \}
00159 
00160 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{unsigned} memory\_usage>
00161 T& BlockwiseImage<T, memory_usage>::operator()(\textcolor{keywordtype}{int} row, \textcolor{keywordtype}{int} col)
00162 \{
00163         BOOST\_ASSERT(0 <= row && row < img\_size.rows && 0 <= col && col < 
      img\_size.cols);
00164         \textcolor{keywordflow}{return} img\_container[index\_method->get\_index(row, col)];
00165 \}
00166 
00167 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{unsigned} memory\_usage>
00168 \textcolor{keyword}{const} T& BlockwiseImage<T, memory_usage>::get_pixel(\textcolor{keywordtype}{int} row, \textcolor{keywordtype}{int} col)\textcolor{keyword}{ const}
00169 \textcolor{keyword}{}\{
00170         \textcolor{keywordflow}{return} this->operator() (row, col);
00171 \}
00172 
00173 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{unsigned} memory\_usage>
00174 T& BlockwiseImage<T, memory_usage>::get_pixel(\textcolor{keywordtype}{int} row, \textcolor{keywordtype}{int} col)
00175 \{
00176         \textcolor{keywordflow}{return} this->operator() (row, col);
00177 \}
00178 
00179 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{unsigned} memory\_usage>
00180 \textcolor{keywordtype}{bool} BlockwiseImage<T, memory_usage>::write_image_head_file(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* 
      file\_name)
00181 \{
00182         \textcolor{keyword}{namespace }bf = boost::filesystem3;
00183         \textcolor{keyword}{using namespace }std;
00184 
00185         \textcolor{keywordflow}{try} \{
00186                 bf::path file\_path(file\_name);
00187                 \textcolor{keywordflow}{if}(bf::is\_directory(file\_path)) \{
00188                         cerr << \textcolor{stringliteral}{"file name should be a normal file"}  << endl;
00189                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00190                 \}
00191 
00192                 \textcolor{keywordflow}{if}(bf::extension(file\_path) != \textcolor{stringliteral}{".bigimage"}) \{
00193                         cerr << \textcolor{stringliteral}{"extension should be bigimage"} << endl;
00194                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00195                 \}
00196 
00197                 \textcolor{keywordflow}{if}(!bf::exists(file\_path.parent\_path()))
00198                         bf::create\_directories(file\_path.parent\_path());
00199         \} \textcolor{keywordflow}{catch}(bf::filesystem\_error &err) \{
00200                 cerr << err.what() << endl;
00201                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00202         \}
00203 
00204         ofstream fout(file\_name, ios::out);
00205         \textcolor{keywordflow}{if}(!fout.is\_open()) \{
00206                 cerr << \textcolor{stringliteral}{"create "} << file\_name << \textcolor{stringliteral}{" failure"} << endl;
00207                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00208         \}
00209 
00210         \textcolor{comment}{/* the head file info */}
00211         fout << \textcolor{stringliteral}{"type="} << \textcolor{stringliteral}{"BlockwiseImage"} << endl;
00212         fout << \textcolor{stringliteral}{"rows="} << img\_size.rows << endl;
00213         fout << \textcolor{stringliteral}{"cols="} << img\_size.cols << endl;
00214         fout << \textcolor{stringliteral}{"filenodesize="} << file\_node\_size << endl;
00215         fout << \textcolor{stringliteral}{"filenodeshiftnum="} << file\_node\_shift\_num << endl;
00216         fout << \textcolor{stringliteral}{"indexmethod="} << index\_method->get\_index\_method\_name() << endl
      ;
00217         fout << \textcolor{stringliteral}{"minirows="} << m\_mini\_rows << endl;
00218         fout << \textcolor{stringliteral}{"minicols="} << m\_mini\_cols << endl;
00219 
00220         fout.close();
00221 
00222         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00223 \}
00224 
00225 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{unsigned} memory\_usage>
00226 \textcolor{keywordtype}{bool} BlockwiseImage<T, memory_usage>::write_image(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* file\_name)
00227 \{
00228         \textcolor{keyword}{using namespace }std;
00229         \textcolor{keyword}{namespace }bf=boost::filesystem3;
00230 
00231         \textcolor{keywordflow}{try} \{
00232                 \textcolor{keywordflow}{if}(!write\_image\_head\_file(file\_name))   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00233 
00234                 bf::path file\_path = file\_name;
00235                 bf::path data\_path = (file\_path.parent\_path() / file\_path.stem(
      )).make\_preferred();
00236                 \textcolor{keywordflow}{if}(bf::exists(data\_path)) \{
00237                         bf::remove\_all(data\_path);
00238                         cout << \textcolor{stringliteral}{"[Warning] : "} << data\_path << \textcolor{stringliteral}{" is existing,
       and the original directory will be removed"} << endl;
00239                 \}
00240 
00241                 \textcolor{comment}{/* block wise image only has one level : means the full size
       level */}
00242                 data\_path /= bf::path(\textcolor{stringliteral}{"level\_0"});
00243                 \textcolor{keywordflow}{if}(!bf::create\_directories(data\_path)) \{
00244                         cerr << \textcolor{stringliteral}{"create directory "} << data\_path << \textcolor{stringliteral}{"failure"} <
      < endl;
00245                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00246                 \}
00247 
00248                 \textcolor{comment}{/* because just read the image data, so just const reference to
       read for some kind of optimization */}
00249                 \textcolor{keyword}{static} \textcolor{keyword}{const} ContainerType &c\_img\_container = img\_container;
00250                 int64 file\_number = std::ceil((\textcolor{keywordtype}{double})(c\_img\_container.size()) 
      / file\_node\_size);
00251 
00252                 \textcolor{comment}{/* first write the full one file context */}
00253                 int64 start\_index = 0, file\_loop = 0;
00254                 \textcolor{keywordflow}{for}(; file\_loop < file\_number - 1; ++file\_loop) \{
00255                         std::ostrstream strstream;
00256                         strstream << data\_path.generic\_string() << \textcolor{stringliteral}{"/"} << 
      file\_loop << \textcolor{charliteral}{'\(\backslash\)0'};
00257                         ofstream file\_out(strstream.str(), ios::out | 
      ios::binary);
00258                         \textcolor{keywordflow}{if}(!file\_out.is\_open()) \{
00259                                 cerr << \textcolor{stringliteral}{"create "} << strstream.str() << \textcolor{stringliteral}{"
       failure"} << endl;
00260                                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00261                         \}
00262 
00263                         start\_index = (int64)(file\_loop) << file\_node\_shift\_num
      ;
00264                         \textcolor{keywordflow}{for}(int64 i = 0; i < file\_node\_size; ++i) \{
00265                                 file\_out.write(reinterpret\_cast<const char*>(&
      c\_img\_container[start\_index + i]), \textcolor{keyword}{sizeof}(T));
00266                         \}
00267                         file\_out.close();
00268                 \}
00269 
00270                 \textcolor{comment}{/* write the last file till the end of the container(maybe not
       full) */}
00271                 start\_index = (int64)(file\_loop) << file\_node\_shift\_num;
00272                 std::ostrstream strstream;
00273                 strstream << data\_path.generic\_string() << \textcolor{stringliteral}{"/"} << file\_loop << \textcolor{charliteral}{
      '\(\backslash\)0'};
00274                 ofstream file\_out(strstream.str(), ios::out | ios::binary);
00275                 \textcolor{keywordflow}{if}(!file\_out.is\_open()) \{
00276                         cerr << \textcolor{stringliteral}{"create "} << strstream.str() << \textcolor{stringliteral}{" failure"} << 
      endl;
00277                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00278                 \}
00279 
00280                 \textcolor{keywordflow}{for}(int64 last\_index = start\_index; last\_index < 
      c\_img\_container.size(); ++last\_index) \{
00281                         file\_out.write(reinterpret\_cast<const char*>(&
      c\_img\_container[last\_index]), \textcolor{keyword}{sizeof}(T));
00282                 \}
00283                 file\_out.close();
00284                 
00285                 \textcolor{keywordflow}{if}(!save\_mini\_image(file\_name)) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00286 
00287         \} \textcolor{keywordflow}{catch}(bf::filesystem\_error &err) \{
00288                 cerr << err.what() << endl;
00289                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00290         \}
00291 
00292         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00293 \}
00294 
00295 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{unsigned} memory\_usage>
00296 \textcolor{keywordtype}{bool} BlockwiseImage<T, memory_usage>::write_image(\textcolor{keyword}{const} std::string &file\_name)
00297 \{
00298         \textcolor{keywordflow}{return} write\_image(file\_name.c\_str());
00299 \}
00300 
00301 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{unsigned} memory\_usage>
00302 \textcolor{keyword}{const} T& BlockwiseImage<T, memory_usage>::at(IndexMethodInterface::IndexType 
      index)\textcolor{keyword}{ const}
00303 \textcolor{keyword}{}\{
00304         BOOST\_ASSERT(index < img\_container.size());
00305         \textcolor{keyword}{static} \textcolor{keyword}{const} ContainerType &c\_img\_container = img\_container;
00306         \textcolor{keywordflow}{return} c\_img\_container[index];
00307 \}
00308 
00309 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{unsigned} memory\_usage>
00310 T& BlockwiseImage<T, memory_usage>::at(IndexMethodInterface::IndexType index)
00311 \{
00312         BOOST\_ASSERT(index < img\_container.size());
00313         \textcolor{keywordflow}{return} img\_container[index];
00314 \}
00315 
00316 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{unsigned} memory\_usage>
00317 \textcolor{keywordtype}{bool} BlockwiseImage<T, memory_usage>::save_mini_image(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *file\_name) 
00318 \{
00319 
00320 \textcolor{preprocessor}{#ifdef SAVE\_MINI\_IMAGE}
00321 \textcolor{preprocessor}{}        \textcolor{keyword}{const} ContainerType &c\_img\_container = img\_container;
00322 
00323         \textcolor{comment}{/* total\_size is the total cell size of the minimum size image}
00324 \textcolor{comment}{         * delta\_count is the delta size when access the minimum size image
       data in }
00325 \textcolor{comment}{         * the whole size img\_container}
00326 \textcolor{comment}{         */}
00327         IndexMethodInterface::IndexType total\_size, file\_cell\_size, delta\_count
      ;
00328         total\_size = c\_img\_container.size();
00329         file\_cell\_size = total\_size >> (2*m\_max\_level);
00330         delta\_count = 1 << (2*m\_max\_level);
00331 
00332         std::vector<T> img\_data(m\_mini\_rows*m\_mini\_cols);
00333         std::vector<T> img\_zorder\_data(file\_cell\_size);
00334 
00335         \textcolor{comment}{/* get the hierarchical image first */}
00336         \textcolor{keywordflow}{for}(IndexMethodInterface::IndexType i = 0, count = 0; i < 
      file\_cell\_size; ++i, count += delta\_count) \{
00337                 img\_zorder\_data[i] = c\_img\_container[count];
00338         \}
00339 
00340         \textcolor{comment}{/* convert it to the row-major format */}
00341         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} row = 0; row < m\_mini\_rows; ++row) \{
00342                 IndexMethodInterface::IndexType row\_result = index\_method->
      get\_row\_result(row);
00343                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} col = 0; col < m\_mini\_cols; ++col) \{
00344                         img\_data[row*m\_mini\_cols+col] = img\_zorder\_data[
      index\_method->get\_index\_by\_row\_result(row\_result, col)];
00345                 \}
00346         \}
00347 
00348     boost::filesystem3::path file\_path = file\_name;
00349     std::string mini\_image\_name = (file\_path.parent\_path() / (file\_path.stem().
      generic\_string() + \textcolor{stringliteral}{".jpg"})).generic\_string();
00350 
00351         \textcolor{comment}{/* save the image into opencv format */}
00352         cv::Mat result\_image(m\_mini\_rows, m\_mini\_cols, CV\_8UC3, img\_data.data()
      );
00353 
00354         \textcolor{comment}{/* convert the RGB format to opencv BGR format */}
00355         cv::cvtColor(result\_image, result\_image, CV\_RGB2BGR);
00356     cv::imwrite(mini\_image\_name.c\_str(), result\_image);
00357 \textcolor{preprocessor}{#endif}
00358 \textcolor{preprocessor}{}
00359         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00360 \}
00361 
00362 \textcolor{comment}{/* deprecated function */}
00363 \textcolor{comment}{//boost::shared\_ptr<BlockwiseImage<T, memory\_usage> > BlockwiseImage<T,
       memory\_usage>::load\_image(const char *file\_name)}
00364 \textcolor{comment}{//\{}
00365 \textcolor{comment}{//      typedef boost::shared\_ptr<BlockwiseImage<T, memory\_usage> > PtrType;}
00366 \textcolor{comment}{//      PtrType dst\_image(new BlockwiseImage<T, memory\_usage> (0, 0));}
00367 \textcolor{comment}{//      PtrType null\_image;}
00368 \textcolor{comment}{//}
00369 \textcolor{comment}{//      if(!dst\_image->load\_image\_head\_file(file\_name)) return null\_image;}
00370 \textcolor{comment}{//}
00371 \textcolor{comment}{//      bf::path file\_path(file\_name);}
00372 \textcolor{comment}{//      bf::path data\_path = (file\_path.parent\_path() /
       file\_path.stem()).make\_preferred();}
00373 \textcolor{comment}{//      data\_path /= "level\_0";}
00374 \textcolor{comment}{//      if(!bf::exists(data\_path)) \{}
00375 \textcolor{comment}{//              cerr << "image data missing" << endl;}
00376 \textcolor{comment}{//              return null\_image;}
00377 \textcolor{comment}{//      \}}
00378 \textcolor{comment}{//}
00379 \textcolor{comment}{//      /* get the new value, then init for using */}
00380 \textcolor{comment}{//      dst\_image->init(dst\_image->get\_image\_rows(),
       dst\_image->get\_image\_cols());}
00381 \textcolor{comment}{//}
00382 \textcolor{comment}{//      ContainerType &img\_container = dst\_image->img\_container;}
00383 \textcolor{comment}{//      int64 file\_number = std::ceil((double)(img\_container.size()) /
       dst\_image->file\_node\_size);}
00384 \textcolor{comment}{//}
00385 \textcolor{comment}{//      int64 start\_index = 0, file\_loop = 0;}
00386 \textcolor{comment}{//      int64 file\_node\_shift\_num = dst\_image->file\_node\_shift\_num;}
00387 \textcolor{comment}{//      int64 file\_node\_size = dst\_image->file\_node\_size;}
00388 \textcolor{comment}{//}
00389 \textcolor{comment}{//      /* first read the full context files */}
00390 \textcolor{comment}{//      for(; file\_loop < file\_number - 1; ++file\_loop) \{}
00391 \textcolor{comment}{//              std::ostrstream strstream;}
00392 \textcolor{comment}{//              strstream << data\_path.generic\_string() << "/" << file\_loop <<
       '\(\backslash\)0';}
00393 \textcolor{comment}{//              if(!bf::exists(bf::path(strstream.str()))) \{}
00394 \textcolor{comment}{//                      cerr << "image data missing" << endl;}
00395 \textcolor{comment}{//                      return null\_image;}
00396 \textcolor{comment}{//              \}}
00397 \textcolor{comment}{//}
00398 \textcolor{comment}{//              /* now read the existing data file */}
00399 \textcolor{comment}{//              ifstream file\_in(strstream.str(), ios::out | ios::binary);}
00400 \textcolor{comment}{//              if(!file\_in.is\_open()) \{}
00401 \textcolor{comment}{//                      cerr << "open" << strstream.str() << " failure" <<
       endl;}
00402 \textcolor{comment}{//                      return null\_image;}
00403 \textcolor{comment}{//              \}}
00404 \textcolor{comment}{//}
00405 \textcolor{comment}{//              start\_index = (int64)(file\_loop) << file\_node\_shift\_num;}
00406 \textcolor{comment}{//              for(int64 i = 0; i < file\_node\_size; ++i) \{}
00407 \textcolor{comment}{//                      
      file\_in.read(reinterpret\_cast<char*>(&img\_container[start\_index + i]), sizeof(T));}
00408 \textcolor{comment}{//              \}}
00409 \textcolor{comment}{//              file\_in.close();}
00410 \textcolor{comment}{//      \}}
00411 \textcolor{comment}{//}
00412 \textcolor{comment}{//      /* now read the last file */}
00413 \textcolor{comment}{//      start\_index = (int64)(file\_loop) << file\_node\_shift\_num;}
00414 \textcolor{comment}{//      std::ostrstream strstream;}
00415 \textcolor{comment}{//      strstream << data\_path.generic\_string() << "/" << file\_loop << '\(\backslash\)0';}
00416 \textcolor{comment}{//      if(!bf::exists(bf::path(strstream.str()))) \{}
00417 \textcolor{comment}{//              cerr << "image data missing" << endl;}
00418 \textcolor{comment}{//              return null\_image;}
00419 \textcolor{comment}{//      \}}
00420 \textcolor{comment}{//      ifstream file\_in(strstream.str(), ios::out | ios::binary);}
00421 \textcolor{comment}{//      if(!file\_in.is\_open()) \{}
00422 \textcolor{comment}{//              cerr << "open" << strstream.str() << " failure" << endl;}
00423 \textcolor{comment}{//              return null\_image;}
00424 \textcolor{comment}{//      \}}
00425 \textcolor{comment}{//      for(int64 last\_index = start\_index; last\_index < img\_container.size();
       ++last\_index) \{}
00426 \textcolor{comment}{//              
      file\_in.read(reinterpret\_cast<char*>(&img\_container[last\_index]), sizeof(T));}
00427 \textcolor{comment}{//      \}}
00428 \textcolor{comment}{//      file\_in.close();}
00429 \textcolor{comment}{//}
00430 \textcolor{comment}{//      return dst\_image;}
00431 \textcolor{comment}{//\}}
00432 
00433 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
