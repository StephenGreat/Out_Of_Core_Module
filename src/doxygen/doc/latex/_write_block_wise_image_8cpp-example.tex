\section{Write\-Block\-Wise\-Image.\-cpp}
This an example of how to write the block wise image into the file system.


\begin{DoxyCodeInclude}
\textcolor{comment}{// WriteBlockWiseImage.cpp : Defines the entry point for the console
       application.}
\textcolor{comment}{//}

\textcolor{preprocessor}{#include "../src/BlockwiseImage.hpp"}

\textcolor{preprocessor}{#include <boost/timer.hpp>}
\textcolor{preprocessor}{#include <boost/progress.hpp>}

\textcolor{comment}{/* opencv part */}
\textcolor{preprocessor}{#include <opencv2/core/core.hpp>}
\textcolor{preprocessor}{#include <opencv2/highgui/highgui.hpp>}
\textcolor{preprocessor}{#include <opencv2/imgproc/imgproc.hpp>}

\textcolor{preprocessor}{#ifdef NDEBUG}
\textcolor{preprocessor}{}\textcolor{preprocessor}{#pragma comment(lib, "opencv\_highgui240.lib")}
\textcolor{preprocessor}{}\textcolor{preprocessor}{#pragma comment(lib, "opencv\_core240.lib")}
\textcolor{preprocessor}{}\textcolor{preprocessor}{#pragma comment(lib, "opencv\_imgproc240.lib")}
\textcolor{preprocessor}{}\textcolor{preprocessor}{#else}
\textcolor{preprocessor}{}\textcolor{preprocessor}{#pragma comment(lib, "opencv\_highgui240d.lib")}
\textcolor{preprocessor}{}\textcolor{preprocessor}{#pragma comment(lib, "opencv\_core240d.lib")}
\textcolor{preprocessor}{}\textcolor{preprocessor}{#pragma comment(lib, "opencv\_imgproc240d.lib")}
\textcolor{preprocessor}{}\textcolor{preprocessor}{#endif}
\textcolor{preprocessor}{}\textcolor{comment}{/*---------------------------------------------*/}

\textcolor{keywordtype}{bool} test\_writing\_blockwise(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)
\{
        \textcolor{keyword}{using namespace }std;

        \textcolor{keywordflow}{if}(argc < 6) \{
                cout << \textcolor{stringliteral}{"Usage : [file name] [res row] [res col] [write image
       file name] [enlarge number]"}
                        \textcolor{stringliteral}{" [optinal (show image)] "} << endl;
                \textcolor{keywordflow}{return} \textcolor{keyword}{false};
        \}

        \textcolor{keyword}{const} \textcolor{keywordtype}{char} *file\_name = argv[1];
        \textcolor{keywordtype}{size\_t} mini\_rows = atoi(argv[2]);
        \textcolor{keywordtype}{size\_t} mini\_cols = atoi(argv[3]);
        \textcolor{keyword}{const} \textcolor{keywordtype}{char} *write\_image\_name = argv[4];
        \textcolor{keywordtype}{size\_t} enlarge\_number = atoi(argv[5]);
        \textcolor{keywordtype}{bool} show\_image = (argc >= 7) ? atoi(argv[6]) : \textcolor{keyword}{false};

        cv::Mat original\_img = cv::imread(file\_name);
        \textcolor{keywordflow}{if}(original\_img.empty()) \{
                cerr << \textcolor{stringliteral}{"Load image error"} << endl;
                \textcolor{keywordflow}{return} \textcolor{keyword}{false};
        \}

        BOOST\_ASSERT\_MSG(original\_img.depth() == CV\_8U, \textcolor{stringliteral}{"image depth not
       correct"});
        BOOST\_ASSERT\_MSG(original\_img.channels() == 3, \textcolor{stringliteral}{"image channels not
       correct"});

        cv::cvtColor(original\_img, original\_img, CV\_BGR2RGB);

        \textcolor{keywordtype}{size\_t} rows = original\_img.rows, cols = original\_img.cols;
        \textcolor{keywordtype}{size\_t} large\_rows = rows * enlarge\_number, large\_cols = cols * 
      enlarge\_number;

        boost::shared\_ptr<IndexMethodInterface> index\_method = 
      boost::make\_shared<ZOrderIndex>(large\_rows, large\_cols);
        \textcolor{comment}{//init the config file}
        \{
                \textcolor{keywordtype}{size\_t} imageBytes = (double)(index\_method->get\_max\_index() * \textcolor{keyword}{
      sizeof}(Vec3b)) / (1024*1024);
                fstream fout(\textcolor{stringliteral}{"config.stxxl"}, ios::out | ios::trunc);
                fout << \textcolor{stringliteral}{"disk=d:\(\backslash\)\(\backslash\)stxxl,"} << (imageBytes * 2) <<\textcolor{stringliteral}{",wincall"} << 
      endl;
                fout.close();
        \}

        \textcolor{keyword}{typedef} BlockwiseImage<Vec3b, 512> ImageType;
        ImageType big\_image(large\_rows, large\_cols, mini\_rows, mini\_cols);
        cout << \textcolor{stringliteral}{"mini\_rows "} << big\_image.get\_minimal\_image\_rows() << endl;
        cout << \textcolor{stringliteral}{"mini\_cols "} << big\_image.get\_minimal\_image\_cols() << endl;
        cout << \textcolor{stringliteral}{"max\_level "} << big\_image.get\_max\_image\_level() << endl;

        \textcolor{comment}{//time related}
        boost::progress\_display pd(enlarge\_number*enlarge\_number);
        boost::timer t;
        t.restart();

        \textcolor{comment}{//the ZOrder part}
        \textcolor{keyword}{typedef} ZOrderIndex::IndexType IndexType;
        \textcolor{keywordflow}{for}(IndexType outI = 0; outI < enlarge\_number; ++outI) \{
                \textcolor{keywordflow}{for}(IndexType outJ = 0; outJ < enlarge\_number; ++outJ) \{
                        IndexType startI = outI * rows;
                        IndexType startJ = outJ * cols;
                        \textcolor{keywordflow}{for}(IndexType i = 0; i < rows; ++i) \{
                                IndexType I = startI + i;
                                \textcolor{keywordflow}{for}(IndexType j = 0; j < cols; ++j) \{
                                        IndexType J = startJ + j;
                                        big\_image(I, J) = *(Vec3b*)(
      original\_img.data + i*original\_img.step[0] + j*original\_img.step[1]);
                                \}
                        \}
                        ++pd;
                \}
        \}
        cout << \textcolor{stringliteral}{"Build Enlarged Image Cost Time : "} << t.elapsed() << \textcolor{stringliteral}{" s "} << 
      endl;

        t.restart();

        \textcolor{comment}{/* 6M per file */}
        big\_image.set\_file\_node\_size(6*1024*1024);

        \textcolor{keywordflow}{if}(!big\_image.write\_image(write\_image\_name)) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
        cout << \textcolor{stringliteral}{"Write Hierarchical Image Cost : "} << t.elapsed() << \textcolor{stringliteral}{" s "} << 
      endl;

        \textcolor{keywordflow}{if}(show\_image) \{
                \textcolor{keyword}{const} ImageType &c\_big\_image = big\_image;
                std::vector<Vec3b> vec(large\_rows*large\_cols);
                \textcolor{keywordflow}{for}(IndexType i = 0; i < big\_image.get\_image\_rows(); ++i) \{
                        \textcolor{keywordflow}{for}(IndexType j = 0; j < big\_image.get\_image\_cols(); ++
      j) \{
                                vec[i*large\_cols  + j] = c\_big\_image(i,j);
                        \}
                \}

                cv::Mat result\_image(large\_rows, large\_cols, CV\_8UC3, vec.data(
      ));
                cv::cvtColor(result\_image, result\_image, CV\_RGB2BGR);
                cv::namedWindow(\textcolor{stringliteral}{"hierarchical image"});
                cv::imshow(\textcolor{stringliteral}{"hierarchical image"}, result\_image);
                cv::waitKey(0);
        \}

        \textcolor{keywordflow}{return} \textcolor{keyword}{true};
\}

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)
\{
        test\_writing\_blockwise(argc, argv);
        \textcolor{keywordflow}{return} 0;
\}

\end{DoxyCodeInclude}
 