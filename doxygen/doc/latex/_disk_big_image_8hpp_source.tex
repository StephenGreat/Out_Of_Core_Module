\section{Disk\-Big\-Image.\-hpp}
\label{_disk_big_image_8hpp}\index{D\-:/\-Out\-\_\-\-Of\-\_\-\-Core\-\_\-\-Git/src/\-Disk\-Big\-Image.\-hpp@{D\-:/\-Out\-\_\-\-Of\-\_\-\-Core\-\_\-\-Git/src/\-Disk\-Big\-Image.\-hpp}}

\begin{DoxyCode}
00001 \textcolor{preprocessor}{#ifndef \_DISK\_BIG\_IMAGE\_HPP}
00002 \textcolor{preprocessor}{}\textcolor{preprocessor}{#define \_DISK\_BIG\_IMAGE\_HPP}
00003 \textcolor{preprocessor}{}\textcolor{preprocessor}{#include "DiskBigImage.h"}
00004 \textcolor{preprocessor}{#include <limits>}
00005 
00006 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00007 \textcolor{keywordtype}{size\_t} DiskBigImage<T>::get_current_level_image_rows()\textcolor{keyword}{ const }
00008 \textcolor{keyword}{}\{
00009         \textcolor{keywordflow}{return} img\_current\_level\_size.rows;
00010 \}
00011 
00012 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00013 \textcolor{keywordtype}{size\_t} DiskBigImage<T>::get_current_level_image_cols()\textcolor{keyword}{ const }
00014 \textcolor{keyword}{}\{
00015         \textcolor{keywordflow}{return} img\_current\_level\_size.cols;
00016 \}
00017 
00018 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00019 \textcolor{keywordtype}{bool} DiskBigImage<T>::set_file_cache_number(\textcolor{keywordtype}{int} \_file\_cache\_number)
00020 \{
00021         \textcolor{keywordflow}{if}(\_file\_cache\_number < 0) \{
00022                 std::cerr << \textcolor{stringliteral}{"DiskBigImage::set\_file\_cache\_number fail :
       invalid file cache number"} << std::endl;
00023                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00024         \}
00025 
00026         file\_cache\_number = \_file\_cache\_number;
00027         lru\_image\_files.init(file\_node\_size, file\_cache\_number);
00028 
00029         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00030 \}
00031 
00032 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00033 \textcolor{keywordtype}{size\_t} DiskBigImage<T>::get_max_image_level()\textcolor{keyword}{ const }
00034 \textcolor{keyword}{}\{
00035         \textcolor{keywordflow}{return} m\_max\_level;
00036 \}
00037 
00038 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00039 \textcolor{keywordtype}{bool} DiskBigImage<T>::set_current_level(\textcolor{keywordtype}{int} level)
00040 \{
00041     \textcolor{keywordflow}{if}(level > m\_max\_level || level < 0) \{
00042                 std::cerr << \textcolor{stringliteral}{"DiskBigImage::set\_current\_level function para
       error : invalid level"} << std::endl;
00043         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00044     \}
00045 
00046         \textcolor{comment}{/* if set the same level, do nothing */}
00047         \textcolor{keywordflow}{if}(m\_current\_level == level)    \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00048 
00049         m\_current\_level = level;
00050 
00051         \textcolor{comment}{/* current image size */}
00052         img\_current\_level\_size.rows = std::ceil((\textcolor{keywordtype}{double})(img\_size.rows) / (1 <<
       level));
00053         img\_current\_level\_size.cols = std::ceil((\textcolor{keywordtype}{double})(img\_size.cols) / (1 <<
       level));
00054 
00055         \textcolor{comment}{/* change the new index method */}
00056         index\_method = boost::shared\_ptr<IndexMethodInterface>(\textcolor{keyword}{new} ZOrderIndex(
      img\_current\_level\_size.rows, img\_current\_level\_size.cols));
00057 
00058         \textcolor{comment}{/* change the image level data path to the specific level*/}
00059         img\_level\_data\_path = img\_data\_path + \textcolor{stringliteral}{"/level\_"} + boost::lexical\_cast<
      std::string>(level);
00060 
00061         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00062 \}
00063 
00064 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00065 \textcolor{keywordtype}{size\_t} DiskBigImage<T>::get_current_level()\textcolor{keyword}{ const }
00066 \textcolor{keyword}{}\{
00067         \textcolor{keywordflow}{return} m\_current\_level;
00068 \}
00069 
00070 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00071 \textcolor{keywordtype}{bool} DiskBigImage<T>::read_from_index_range(\textcolor{keywordtype}{size\_t} front, \textcolor{keywordtype}{size\_t} tail, 
      ZOrderIndex::IndexType start\_index, 
00072         \textcolor{keyword}{const} std::vector<DataIndexInfo> &index\_info\_vector, std::vector<T> &
      data\_vector)
00073 \{
00074         \textcolor{keyword}{using namespace }std;
00075 
00076         BOOST\_ASSERT(tail > front);
00077 
00078         \textcolor{comment}{/* total number for reading */}
00079         \textcolor{keywordtype}{size\_t} total = tail - front;
00080 
00081         \textcolor{comment}{/* save the actually first zorder index (take account of the
       start\_index) */}
00082         \textcolor{keywordtype}{size\_t} zorder\_index\_front = index\_info\_vector[front].zorder\_index + 
      start\_index;
00083 
00084         \textcolor{comment}{/* the first image file number */}
00085         \textcolor{keywordtype}{size\_t} start\_file\_number = (zorder\_index\_front >> file\_node\_shift\_num);
00086 
00087         \textcolor{comment}{/* the seekg cell size in the file */}
00088         \textcolor{keywordtype}{size\_t} start\_seekg = zorder\_index\_front - (start\_file\_number << 
      file\_node\_shift\_num);
00089 
00090         \textcolor{comment}{/* while the cell number has not been finished */}
00091         \textcolor{keywordflow}{while}(total > 0) \{
00092                 \textcolor{comment}{/* image file name */}
00093                 \textcolor{keywordtype}{string} img\_file\_name = img\_level\_data\_path + \textcolor{charliteral}{'/'} + 
      boost::lexical\_cast<\textcolor{keywordtype}{string}>(start\_file\_number);
00094 
00095                 \textcolor{comment}{/* the file\_index means the index of the img\_file\_name in
       lru\_image\_files */}
00096                 \textcolor{keywordtype}{int} file\_index = lru\_image\_files.put\_into\_lru(img\_file\_name);
00097 
00098                 \textcolor{comment}{/* if not get the reasonable position, there must be some kind
       of error, so just return false */}
00099                 \textcolor{keywordflow}{if}(file\_index == lru\_image\_files.npos)  \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00100 
00101                 \textcolor{keyword}{const} vector<Vec3b> &file\_data = lru\_image\_files.get\_data(
      file\_index);
00102 
00103                 \textcolor{keywordtype}{size\_t} read\_number = min<size\_t>(tail - front, file\_node\_size -
       start\_seekg);
00104 
00105                 \textcolor{comment}{/* write data into the front location */}
00106                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < read\_number; ++i) \{
00107                         data\_vector[index\_info\_vector[front++].index] = 
      file\_data[start\_seekg + i];
00108                 \}
00109 
00110                 total -= read\_number;
00111                 \textcolor{keywordflow}{if}(total <= 0)  \textcolor{keywordflow}{break};
00112 
00113                 \textcolor{comment}{/* here means prepare for next loop */}
00114                 \textcolor{comment}{/* make the seekg = 0, means in later loop the seekg will just
       begin from the start point of each file for reading */}
00115                 start\_seekg = 0;
00116 
00117                 \textcolor{comment}{/* the next file is just one number larger than formal image */}
00118                 ++start\_file\_number;
00119         \}
00120 
00121         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00122 \}
00123 
00124 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00125 \textcolor{keywordtype}{bool} DiskBigImage<T>::check_para_validation(\textcolor{keywordtype}{int} level, \textcolor{keywordtype}{int} start\_row, \textcolor{keywordtype}{int} 
      start\_col, \textcolor{keywordtype}{int} rows, \textcolor{keywordtype}{int} cols) 
00126 \{
00127         \textcolor{keyword}{using namespace }std;
00128 
00129         \textcolor{keywordflow}{if}(!set\_current\_level(level)) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00130 
00131         \textcolor{keywordflow}{if}(start\_row >= img\_current\_level\_size.rows || start\_row < 0) \{
00132                 cerr << \textcolor{stringliteral}{"DiskBigImage::get\_pixels\_by\_level function para error
       : invalid start\_rows"} << endl;
00133                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00134         \}
00135 
00136         \textcolor{keywordflow}{if}(start\_col >= img\_current\_level\_size.cols || start\_col < 0) \{
00137                 cerr << \textcolor{stringliteral}{"DiskBigImage::get\_pixels\_by\_level function para error
       : invalid start\_cols"} << endl;
00138                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00139         \}
00140 
00141         \textcolor{keywordflow}{if}(start\_row + rows > img\_current\_level\_size.rows || rows < 0) \{
00142                 cerr << \textcolor{stringliteral}{"DiskBigImage::get\_pixels\_by\_level function para error
       : invalid rows"}<< endl;
00143                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00144         \}
00145 
00146         \textcolor{keywordflow}{if}(start\_col + cols > img\_current\_level\_size.cols || cols < 0) \{
00147                 cerr << \textcolor{stringliteral}{"DiskBigImage::get\_pixels\_by\_level function para err :
       invalid cols"} << endl;
00148                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00149         \}
00150 
00151         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00152 \}
00153 
00154 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00155 \textcolor{keywordtype}{bool} DiskBigImage<T>::get_pixels_by_level(\textcolor{keywordtype}{int} level, \textcolor{keywordtype}{int} start\_row, \textcolor{keywordtype}{int} 
      start\_col, \textcolor{keywordtype}{int} rows, \textcolor{keywordtype}{int} cols, std::vector<T> &vec)
00156 \{
00157         \textcolor{keyword}{using namespace }std;
00158 
00159         \textcolor{keywordflow}{if}(!check\_para\_validation(level, start\_row, start\_col, rows, cols)) \textcolor{keywordflow}{
      return} \textcolor{keyword}{false};
00160 
00161         \textcolor{comment}{/* save the zorder indexing method information*/}
00162         std::vector<DataIndexInfo> index\_info\_vector(rows*cols);
00163 
00164         \textcolor{comment}{/* save the actual image data in row-major */}
00165         vec.resize(rows*cols);
00166 
00167         \textcolor{comment}{/* the start index of the image range, thus the zorder index of the
       top-left point */}
00168         ZOrderIndex::IndexType start\_zorder\_index = index\_method->get\_index(
      start\_row, start\_col);
00169 
00170         \textcolor{comment}{/* initialize the data index information */} 
00171         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < rows; ++i) \{
00172                 ZOrderIndex::IndexType row\_result = index\_method->
      get\_row\_result(i + start\_row);
00173                 \textcolor{keywordtype}{size\_t} row\_index = i*cols;      
00174                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} j = 0; j < cols; ++j) \{
00175                         index\_info\_vector[row\_index + j].index = row\_index + j;
00176                         index\_info\_vector[row\_index + j].zorder\_index = 
00177                                 index\_method->get\_index\_by\_row\_result(
      row\_result, j + start\_col) - start\_zorder\_index; 
00178                 \}
00179         \}
00180 
00181         \textcolor{comment}{/* sort the index info vector by the zorder index value */}
00182         std::sort(index\_info\_vector.begin(), index\_info\_vector.end());
00183 
00184         \textcolor{comment}{/* front and tail means a range of the successive zorder index in
       format [front, tail) */}
00185         \textcolor{keywordtype}{size\_t} front = 0, tail = 0;
00186         \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} end = rows*cols;  
00187 
00188         \textcolor{comment}{/* first make the front and tail the same, the expect\_index means the
       expect zorder index when searching in successive way*/}
00189         front = tail = 0;
00190         ZOrderIndex::IndexType expect\_index = index\_info\_vector[front].
      zorder\_index;
00191         \textcolor{keywordflow}{while}(front < end) \{
00192                 expect\_index = index\_info\_vector[front].zorder\_index;
00193 
00194                 \textcolor{keywordflow}{while}(tail < end && expect\_index == index\_info\_vector[tail].
      zorder\_index) \{
00195                         ++tail;
00196                         ++expect\_index;
00197                 \}
00198 
00199                 \textcolor{comment}{/*now get the successive zorder index range [front, tail) */}
00200                 \{
00201                         BOOST\_ASSERT(tail > front);
00202 
00203                         \textcolor{comment}{/* total number for reading */}
00204                         \textcolor{keywordtype}{size\_t} total = tail - front;
00205 
00206                         \textcolor{comment}{/* save the actually first zorder index (take account
       of the start\_zorder\_index) */}
00207                         \textcolor{keywordtype}{size\_t} zorder\_index\_front = index\_info\_vector[front].
      zorder\_index + start\_zorder\_index;
00208 
00209                         \textcolor{comment}{/* the first image file number */}
00210                         \textcolor{keywordtype}{size\_t} start\_file\_number = (zorder\_index\_front >> 
      file\_node\_shift\_num);
00211 
00212                         \textcolor{comment}{/* the seekg cell size in the file */}
00213                         \textcolor{keywordtype}{size\_t} start\_seekg = zorder\_index\_front - (
      start\_file\_number << file\_node\_shift\_num);
00214 
00215                         \textcolor{comment}{/* while the cell number has not been finished */}
00216                         \textcolor{keywordflow}{while}(total > 0) \{
00217                                 \textcolor{comment}{/* image file name */}
00218                                 \textcolor{keywordtype}{string} img\_file\_name = img\_level\_data\_path + \textcolor{charliteral}{
      '/'} + boost::lexical\_cast<\textcolor{keywordtype}{string}>(start\_file\_number);
00219 
00220                                 \textcolor{comment}{/* the file\_index means the index of the
       img\_file\_name in lru\_image\_files */}
00221                                 \textcolor{keywordtype}{int} file\_index = lru\_image\_files.put\_into\_lru(
      img\_file\_name);
00222 
00223                                 \textcolor{comment}{/* if not get the reasonable position, there
       must be some kind of error, so just return false */}
00224                                 \textcolor{keywordflow}{if}(file\_index == lru\_image\_files.npos)  \textcolor{keywordflow}{return} \textcolor{keyword}{
      false};
00225 
00226                                 \textcolor{keyword}{const} vector<Vec3b> &file\_data = 
      lru\_image\_files.get\_const\_data(file\_index);
00227 
00228                                 \textcolor{keywordtype}{size\_t} read\_number = min<size\_t>(tail - front, 
      file\_node\_size - start\_seekg);
00229 
00230                                 \textcolor{comment}{/* write data into the front location */}
00231                                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < read\_number; ++i) \{
00232                                         vec[index\_info\_vector[front++].index] =
       file\_data[start\_seekg + i];
00233                                 \}
00234 
00235                                 total -= read\_number;
00236                                 \textcolor{keywordflow}{if}(total <= 0)  \textcolor{keywordflow}{break};
00237 
00238                                 \textcolor{comment}{/* here means prepare for next loop */}
00239                                 \textcolor{comment}{/* make the seekg = 0, means in later loop the
       seekg will just begin from the */}
00240                                 \textcolor{comment}{/* start point of each file for reading */}
00241                                 start\_seekg = 0;
00242 
00243                                 \textcolor{comment}{/* the next file is just one number larger than
       formal image */}
00244                                 ++start\_file\_number;
00245                         \}
00246                 \}
00247 
00248                 front = tail;
00249         \}
00250 
00251         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00252 \}
00253 
00254 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00255 \textcolor{keywordtype}{bool} DiskBigImage<T>::get_pixels_by_level_fast(\textcolor{keywordtype}{int} level, \textcolor{keywordtype}{int} &start\_row, \textcolor{keywordtype}{int} &
      start\_col,
00256         \textcolor{keywordtype}{int} &rows, \textcolor{keywordtype}{int} &cols, std::vector<T> &vec)
00257 \{
00258         \textcolor{keyword}{using namespace }std;
00259 
00260         \textcolor{keywordflow}{if}(!check\_para\_validation(level, start\_row, start\_col, rows, cols)) \textcolor{keywordflow}{
      return} \textcolor{keyword}{false};
00261 
00262         \textcolor{comment}{/* first recalculate the para to get the most fast suitable para */}
00263         start\_row = make\_less\_four\_multiply(start\_row);
00264         start\_col = make\_less\_four\_multiply(start\_col);
00265         rows = make\_less\_four\_multiply(rows);
00266         cols = make\_less\_four\_multiply(cols);
00267 
00268         \textcolor{keywordflow}{return} get\_pixels\_by\_level(level, start\_row, start\_col, rows, cols, vec
      );
00269 \}
00270 
00271 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00272 \textcolor{keywordtype}{bool} DiskBigImage<T>::set_pixel_by_level(\textcolor{keywordtype}{int} level, \textcolor{keywordtype}{int} start\_row, \textcolor{keywordtype}{int} 
      start\_col, 
00273         \textcolor{keywordtype}{int} rows, \textcolor{keywordtype}{int} cols, \textcolor{keyword}{const} std::vector<T> &vec)
00274 \{       
00275         \textcolor{keyword}{using namespace }std;
00276 
00277         \textcolor{keywordflow}{if}(!check\_para\_validation(level, start\_row, start\_col, rows, cols)) \textcolor{keywordflow}{
      return} \textcolor{keyword}{false};
00278 
00279         \textcolor{comment}{/* save the zorder indexing method information*/}
00280         std::vector<DataIndexInfo> index\_info\_vector(rows*cols);
00281 
00282         \textcolor{comment}{/* the start index of the image range, thus the zorder index of the
       top-left point */}
00283         ZOrderIndex::IndexType start\_zorder\_index = index\_method->get\_index(
      start\_row, start\_col);
00284 
00285         \textcolor{comment}{/* initialize the data index information */} 
00286         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < rows; ++i) \{
00287                 ZOrderIndex::IndexType row\_result = index\_method->
      get\_row\_result(i + start\_row);
00288                 \textcolor{keywordtype}{size\_t} row\_index = i*cols;      
00289                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} j = 0; j < cols; ++j) \{
00290                         index\_info\_vector[row\_index + j].index = row\_index + j;
00291                         index\_info\_vector[row\_index + j].zorder\_index = 
00292                                 index\_method->get\_index\_by\_row\_result(
      row\_result, j + start\_col) - start\_zorder\_index; 
00293                 \}
00294         \}
00295 
00296         \textcolor{comment}{/* sort the index info vector by the zorder index value */}
00297         std::sort(index\_info\_vector.begin(), index\_info\_vector.end());
00298 
00299         \textcolor{comment}{/* front and tail means a range of the successive zorder index in
       format [front, tail) */}
00300         \textcolor{keywordtype}{size\_t} front = 0, tail = 0;
00301         \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} end = rows*cols;  
00302 
00303         \textcolor{comment}{/* first make the front and tail the same, the expect\_index means the
       expect zorder index when searching in successive way*/}
00304         front = tail = 0;
00305         ZOrderIndex::IndexType expect\_index = index\_info\_vector[front].
      zorder\_index;
00306         \textcolor{keywordflow}{while}(front < end) \{
00307                 expect\_index = index\_info\_vector[front].zorder\_index;
00308 
00309                 \textcolor{keywordflow}{while}(tail < end && expect\_index == index\_info\_vector[tail].
      zorder\_index) \{
00310                         ++tail;
00311                         ++expect\_index;
00312                 \}
00313 
00314                 \textcolor{comment}{/*now get the successive zorder index range [front, tail) */}
00315                 \{
00316                         BOOST\_ASSERT(tail > front);
00317 
00318                         \textcolor{comment}{/* total number for reading */}
00319                         \textcolor{keywordtype}{size\_t} total = tail - front;
00320 
00321                         \textcolor{comment}{/* save the actually first zorder index (take account
       of the start\_zorder\_index) */}
00322                         \textcolor{keywordtype}{size\_t} zorder\_index\_front = index\_info\_vector[front].
      zorder\_index + start\_zorder\_index;
00323 
00324                         \textcolor{comment}{/* the first image file number */}
00325                         \textcolor{keywordtype}{size\_t} start\_file\_number = (zorder\_index\_front >> 
      file\_node\_shift\_num);
00326 
00327                         \textcolor{comment}{/* the seekg cell size in the file */}
00328                         \textcolor{keywordtype}{size\_t} start\_seekg = zorder\_index\_front - (
      start\_file\_number << file\_node\_shift\_num);
00329 
00330                         \textcolor{comment}{/* while the cell number has not been finished */}
00331                         \textcolor{keywordflow}{while}(total > 0) \{
00332                                 \textcolor{comment}{/* image file name */}
00333                                 \textcolor{keywordtype}{string} img\_file\_name = img\_level\_data\_path + \textcolor{charliteral}{
      '/'} + boost::lexical\_cast<\textcolor{keywordtype}{string}>(start\_file\_number);
00334 
00335                                 \textcolor{comment}{/* the file\_index means the index of the
       img\_file\_name in lru\_image\_files */}
00336                                 \textcolor{keywordtype}{int} file\_index = lru\_image\_files.put\_into\_lru(
      img\_file\_name);
00337 
00338                                 \textcolor{comment}{/* if not get the reasonable position, there
       must be some kind of error, so just return false */}
00339                                 \textcolor{keywordflow}{if}(file\_index == lru\_image\_files.npos)  \textcolor{keywordflow}{return} \textcolor{keyword}{
      false};
00340 
00341                                 \textcolor{comment}{/* using get\_data function will make the
       file\_index cache be dirty, thus will be write back when the cache is swap out }
00342 \textcolor{comment}{                                 * of the memory */}
00343                                 vector<Vec3b> &file\_data = lru\_image\_files.
      get\_data(file\_index);
00344 
00345                                 \textcolor{keywordtype}{size\_t} read\_number = std::min<size\_t>(tail - 
      front, file\_node\_size - start\_seekg);
00346 
00347                                 \textcolor{comment}{/* just read the data into the right place */}
00348                                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < read\_number; ++i) \{
00349                                         file\_data[start\_seekg + i] = vec[
      index\_info\_vector[front++].index];
00350                                 \}
00351 
00352                                 total -= read\_number;
00353                                 \textcolor{keywordflow}{if}(total <= 0)  \textcolor{keywordflow}{break};
00354 
00355                                 \textcolor{comment}{/* here means prepare for next loop */}
00356                                 \textcolor{comment}{/* make the seekg = 0, means in later loop the
       seekg will just begin from the */}
00357                                 \textcolor{comment}{/* start point of each file for reading */}
00358                                 start\_seekg = 0;
00359 
00360                                 \textcolor{comment}{/* the next file is just one number larger than
       formal image */}
00361                                 ++start\_file\_number;
00362                         \}
00363                 \}
00364 
00365                 front = tail;
00366         \}
00367 
00368         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00369 \}
00370 
00371 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00372 \textcolor{keywordtype}{bool} DiskBigImage<T>::load_image_head_file(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* file\_name)
00373 \{
00374         \textcolor{keyword}{using namespace }std;
00375         \textcolor{keyword}{namespace }bf = boost::filesystem3;
00376 
00377         \textcolor{comment}{/* first check file existence */}
00378         \textcolor{keywordflow}{try} \{
00379                 bf::path file\_path(file\_name);
00380                 \textcolor{keywordflow}{if}(!bf::exists(file\_path)) \{
00381                         cerr << \textcolor{stringliteral}{"not exists the bigimage file"} << endl;
00382                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00383                 \}
00384                 \textcolor{keywordflow}{if}(!bf::is\_regular\_file(file\_path)) \{
00385                         cerr << \textcolor{stringliteral}{"file name is not a regular file"} << endl;
00386                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00387                 \}
00388                 \textcolor{keywordflow}{if}(bf::extension(file\_path) != \textcolor{stringliteral}{".bigimage"}) \{
00389                         cerr << \textcolor{stringliteral}{"extension should be bigimage"} << endl;
00390                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00391                 \}
00392         \} \textcolor{keywordflow}{catch}(bf::filesystem\_error &err) \{
00393                 cerr << err.what() << endl;
00394                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00395         \}
00396 
00397         ifstream fin(file\_name, ios::in);
00398         \textcolor{keywordflow}{if}(!fin.is\_open()) \{
00399                 cerr << file\_name << \textcolor{stringliteral}{" can't be opened for reading"} << endl;
00400                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00401         \}
00402 
00403         \textcolor{keywordtype}{string} str;
00404         string::size\_type index = 0;
00405         getline(fin, str);
00406 
00407         \textcolor{comment}{/* check image head type */}
00408         \textcolor{keywordflow}{if}(str != \textcolor{stringliteral}{"type=BlockwiseImage"}) \{
00409                 cerr << \textcolor{stringliteral}{"image format is not correct"} << endl;
00410                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00411         \}
00412 
00413         \textcolor{keywordflow}{try} \{
00414                 \textcolor{comment}{/* get the image rows */}
00415                 getline(fin, str);
00416                 index = str.find(\textcolor{charliteral}{'='});
00417                 \textcolor{keywordflow}{if}(index == string::npos || str.substr(0, index) != \textcolor{stringliteral}{"rows"}) \{
00418                         cerr << \textcolor{stringliteral}{"image format is not correct"} << endl;
00419                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00420                 \}
00421                 img\_size.rows = boost::lexical\_cast<\textcolor{keywordtype}{size\_t}>(str.substr(index+1)
      );
00422 
00423                 \textcolor{comment}{/* get the image cols */}
00424                 getline(fin, str);
00425                 index = str.find(\textcolor{charliteral}{'='});
00426                 \textcolor{keywordflow}{if}(index == string::npos || str.substr(0, index) != \textcolor{stringliteral}{"cols"}) \{
00427                         cerr << \textcolor{stringliteral}{"image format is not correct"} << endl;
00428                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00429                 \}
00430                 img\_size.cols = boost::lexical\_cast<\textcolor{keywordtype}{size\_t}>(str.substr(index+1)
      );
00431 
00432                 \textcolor{comment}{/* get the file node size */}
00433                 getline(fin, str);
00434                 index = str.find(\textcolor{charliteral}{'='});
00435                 \textcolor{keywordflow}{if}(index == string::npos || str.substr(0, index) != \textcolor{stringliteral}{"
      filenodesize"}) \{
00436                         cerr << \textcolor{stringliteral}{"image format is not correct"} << endl;
00437                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00438                 \}
00439                 file\_node\_size = boost::lexical\_cast<\textcolor{keywordtype}{size\_t}>(str.substr(index+1
      ));
00440 
00441                 \textcolor{comment}{/* get the file node shift number */}
00442                 getline(fin, str);
00443                 index = str.find(\textcolor{charliteral}{'='});
00444                 \textcolor{keywordflow}{if}(index == string::npos || str.substr(0, index) != \textcolor{stringliteral}{"
      filenodeshiftnum"}) \{
00445                         cerr << \textcolor{stringliteral}{"image format is not correct"} << endl;
00446                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00447                 \}
00448                 file\_node\_shift\_num = boost::lexical\_cast<\textcolor{keywordtype}{size\_t}>(str.substr(
      index+1));
00449 
00450                 \textcolor{comment}{/* get the index method */}
00451                 getline(fin, str);
00452                 index = str.find(\textcolor{charliteral}{'='});
00453                 \textcolor{keywordflow}{if}(index == string::npos || str.substr(0, index) != \textcolor{stringliteral}{"
      indexmethod"}) \{
00454                         cerr << \textcolor{stringliteral}{"image format is not correct"} << endl;
00455                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00456                 \}
00457                 \textcolor{keywordtype}{string} index\_str = str.substr(index+1);
00458                 \textcolor{keywordflow}{if}(index\_str == \textcolor{stringliteral}{"ZOrderIndex"}) \{
00459                         index\_method = boost::make\_shared<ZOrderIndex>(img\_size
      .rows, img\_size.cols);
00460                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (index\_str == \textcolor{stringliteral}{"ZOrderIndexIntuition"}) \{
00461                         index\_method = boost::make\_shared<ZOrderIndexIntuition>
      (img\_size.rows, img\_size.cols);
00462                 \} \textcolor{keywordflow}{else} \{
00463                         cerr << \textcolor{stringliteral}{"image format is not correct"} << endl;
00464                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00465                 \}
00466 
00467         \textcolor{comment}{/* get the image mini rows */}
00468         getline(fin, str);
00469         index = str.find(\textcolor{charliteral}{'='});
00470         \textcolor{keywordflow}{if}(index == string::npos || str.substr(0, index) != \textcolor{stringliteral}{"minirows"}) \{
00471             cerr << \textcolor{stringliteral}{"image format is not correct"} << endl;
00472             \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00473         \}
00474         m\_mini\_rows = boost::lexical\_cast<\textcolor{keywordtype}{size\_t}>(str.substr(index+1));
00475 
00476         \textcolor{comment}{/* get the image mini cols */}
00477         getline(fin, str);
00478         index = str.find(\textcolor{charliteral}{'='});
00479         \textcolor{keywordflow}{if}(index == string::npos || str.substr(0, index) != \textcolor{stringliteral}{"minicols"}) \{
00480             cerr << \textcolor{stringliteral}{"image format is not correct"} << endl;
00481             \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00482         \}
00483         m\_mini\_cols = boost::lexical\_cast<\textcolor{keywordtype}{size\_t}>(str.substr(index+1));
00484 
00485                 \textcolor{comment}{/* this is hierarchical part */}
00486         \textcolor{comment}{/* get the hierarchal image max scale level */}
00487         getline(fin, str);
00488 
00489                 \textcolor{comment}{/* this means this is just the blockwiseimage, so the max level
       is 0 only */}
00490                 \textcolor{keywordflow}{if}(fin.eof()) \{
00491                         m\_max\_level = 0;
00492                         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00493                 \}
00494 
00495         index = str.find(\textcolor{charliteral}{'='});
00496         \textcolor{keywordflow}{if}(index == string::npos || str.substr(0, index) != \textcolor{stringliteral}{"maxlevel"}) \{
00497             cerr << \textcolor{stringliteral}{"image format is not correct"} << endl;
00498             \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00499         \}
00500         m\_max\_level = boost::lexical\_cast<\textcolor{keywordtype}{size\_t}>(str.substr(index+1));
00501 
00502                 getline(fin, str);
00503         \textcolor{keywordflow}{if}(fin.eof()) \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00504         \textcolor{keywordflow}{if}(fin.fail()) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00505 
00506         fin.close();
00507                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00508 
00509         \} \textcolor{keywordflow}{catch}(boost::bad\_lexical\_cast &err) \{
00510                 cerr << err.what() << endl;
00511                 fin.close();
00512                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00513         \}
00514 \}
00515 
00516 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00517 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} DiskBigImage<T>::set_image_data_path(\textcolor{keyword}{const} \textcolor{keywordtype}{char} * file\_name) 
00518 \{
00519         \textcolor{keyword}{namespace }bf = boost::filesystem3;
00520 
00521         \textcolor{comment}{/* save the img\_data\_path */}
00522         bf::path file\_path = file\_name;
00523         img\_data\_path = (file\_path.parent\_path() / file\_path.stem()).
      generic\_string();
00524 \}
00525 
00526 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00527 boost::shared\_ptr<DiskBigImage<T> > load\_disk\_image(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *file\_name)
00528 \{
00529         \textcolor{keyword}{typedef} boost::shared\_ptr<DiskBigImage<T> > PtrType;
00530         PtrType dst\_image(\textcolor{keyword}{new} DiskBigImage<T>);
00531         PtrType null\_image;
00532 
00533         \textcolor{keywordflow}{if}(!dst\_image->load\_image\_head\_file(file\_name))  \textcolor{keywordflow}{return} null\_image;
00534 
00535         \textcolor{comment}{/* initialization the default config para */}
00536         \textcolor{comment}{/* by default, the cache number is 16 */}
00537         dst\_image->set\_file\_cache\_number(16);
00538 
00539         \textcolor{comment}{/* set the image data path for some kind of optimization when calling
       set or get pixels functions */}
00540         dst\_image->set\_image\_data\_path(file\_name);
00541 
00542         \textcolor{comment}{/* set the current level to be the max : let it different from the
       first level user will be }
00543 \textcolor{comment}{         * set in the set\_current\_level() function */}
00544         dst\_image->m\_current\_level = std::numeric\_limits<size\_t>::max();
00545 
00546         \textcolor{comment}{/*}
00547 \textcolor{comment}{         * hierarchical image don't save specific level image data}
00548 \textcolor{comment}{         * when using set\_current\_level function to set current level}
00549 \textcolor{comment}{         * then using any kind of image access function, the data will be}
00550 \textcolor{comment}{         * dynamically loaded, and of course there will be some kind of
       performance penalty}
00551 \textcolor{comment}{         */}
00552         \textcolor{keywordflow}{return} dst\_image;
00553 \}
00554 
00555 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00556 boost::shared\_ptr<DiskBigImage<T> > load\_disk\_image(\textcolor{keyword}{const} std::string &
      file\_name)
00557 \{
00558         \textcolor{keywordflow}{return} load\_disk\_image<T>(file\_name.c\_str());
00559 \}
00560 
00561 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
