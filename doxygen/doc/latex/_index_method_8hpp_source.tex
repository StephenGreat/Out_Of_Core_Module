\section{Index\-Method.\-hpp}
\label{_index_method_8hpp}\index{D\-:/\-Out\-\_\-\-Of\-\_\-\-Core\-\_\-\-Git/src/\-Index\-Method.\-hpp@{D\-:/\-Out\-\_\-\-Of\-\_\-\-Core\-\_\-\-Git/src/\-Index\-Method.\-hpp}}

\begin{DoxyCode}
00001 \textcolor{preprocessor}{#ifndef \_INDEX\_METHOD\_HPP}
00002 \textcolor{preprocessor}{}\textcolor{preprocessor}{#define \_INDEX\_METHOD\_HPP}
00003 \textcolor{preprocessor}{}
00004 \textcolor{preprocessor}{#include "IndexMethodInterface.h"}
00005 \textcolor{preprocessor}{#include <cmath>}
00006 \textcolor{preprocessor}{#include <boost/assert.hpp>}
00007 
00008 \textcolor{keyword}{class }Block2DIndex : \textcolor{keyword}{public} IndexMethodInterface
00009 \{
00010 \textcolor{keyword}{private}:
00011 
00012         \textcolor{comment}{//the size of the array}
00013         IndexType m\_row, m\_col;
00014 
00015         \textcolor{comment}{//the size of the block area (the shift distance)}
00016         IndexType m\_blockRowSize, m\_blockColSize;
00017 
00018         \textcolor{comment}{//the count of block along with each axis of the 2D array}
00019         IndexType m\_blockRowCount, m\_blockColCount;
00020 
00021         \textcolor{comment}{//the total size of the block (the shift distance)}
00022         IndexType m\_blockTotalSize;
00023 
00024 \textcolor{keyword}{private}:
00025         \textcolor{keyword}{typedef} IndexType ValueType;
00026         \textcolor{keyword}{const} IndexType ONE;
00027 
00028 \textcolor{keyword}{public}:
00029 
00036         Block2DIndex(IndexType row\_size, IndexType col\_size, IndexType 
      block\_row\_size, IndexType block\_col\_size = -1)
00037                 : m\_row(row\_size), m\_col(col\_size), m\_blockRowSize(
      block\_row\_size),
00038                         m\_blockColSize((block\_col\_size == -1) ? block\_row\_size 
      : block\_col\_size), ONE(1)
00039         \{
00040                 BOOST\_ASSERT\_MSG(block\_row\_size <= (IndexType)(std::log((\textcolor{keywordtype}{double}
      )row\_size) / std::log(2.0)),
00041                         \textcolor{stringliteral}{"block row size must less than log2(row\_size)"});
00042 
00043                 BOOST\_ASSERT\_MSG(block\_col\_size <= (IndexType)(std::log((\textcolor{keywordtype}{double}
      )col\_size) / std::log(2.0)),
00044                         \textcolor{stringliteral}{"block col size must less than log2(col\_size)"});
00045 
00046                 ValueType result, mod;
00047 
00048                 result = (m\_row >> block\_row\_size); mod = m\_row - (result << 
      block\_row\_size);
00049                 m\_blockRowCount = result + ((mod == 0) ? 0 : 1);
00050 
00051                 result = (m\_col >> block\_col\_size); mod = m\_col - (result << 
      block\_col\_size);
00052                 m\_blockColCount = result + ((mod == 0) ? 0 : 1);
00053 
00054                 m\_blockTotalSize = (block\_row\_size + block\_col\_size);
00055         \}
00056 
00057 \textcolor{comment}{/* implement the interface */}
00058 \textcolor{keyword}{public}:
00059         \textcolor{keyword}{virtual} IndexType get_index(RowMajorIndexType row\_index, 
      RowMajorIndexType col\_index)\textcolor{keyword}{ const}
00060 \textcolor{keyword}{        }\{
00061                 IndexType bx, by, dx, dy;
00062                 bx = (row\_index >> m\_blockRowSize); dx = row\_index - (bx << 
      m\_blockRowSize);
00063                 by = (col\_index >> m\_blockColSize); dy = col\_index - (by << 
      m\_blockColSize);
00064 
00065                 \textcolor{keywordflow}{return} ((bx*m\_blockColCount + by) << m\_blockTotalSize) + (dx <<
       m\_blockColSize) + dy;
00066         \}
00067 
00068         \textcolor{keyword}{virtual} RowMajorPoint get_origin_index(IndexType index)\textcolor{keyword}{ const}
00069 \textcolor{keyword}{        }\{
00070                 IndexType result, mod;
00071                 result = index >> m\_blockTotalSize; mod = index - (result << 
      m\_blockTotalSize);
00072 
00073                 IndexType bx, by, dx, dy;
00074                 bx = result / m\_blockColCount; by = result - (bx * 
      m\_blockColCount);
00075                 dx = mod >> m\_blockColSize; dy = mod - (dx << m\_blockColSize);
00076 
00077                 \textcolor{keywordflow}{return} RowMajorPoint((bx << m\_blockRowSize) + dx, (by << 
      m\_blockColSize) + dy);
00078         \}
00079 
00080         \textcolor{keyword}{virtual} IndexType get_row_result(RowMajorIndexType row\_index)\textcolor{keyword}{ const}
00081 \textcolor{keyword}{        }\{
00082                 IndexType bx, dx;
00083                 bx = (row\_index >> m\_blockRowSize); dx = row\_index - (bx << 
      m\_blockRowSize);
00084                 \textcolor{keywordflow}{return} ((bx*m\_blockColCount) << m\_blockTotalSize) + (dx << 
      m\_blockColSize);
00085         \}
00086 
00087         \textcolor{keyword}{virtual} IndexType get_index_by_row_result(IndexType row\_result, 
      RowMajorIndexType col\_index)\textcolor{keyword}{ const}
00088 \textcolor{keyword}{        }\{
00089                 IndexType by, dy;
00090                 by = (col\_index >> m\_blockColSize); dy = col\_index - (by << 
      m\_blockColSize);
00091                 \textcolor{keywordflow}{return} row\_result + (by << m\_blockTotalSize) + dy;
00092         \}
00093 
00094         \textcolor{keyword}{virtual} IndexType get_max_index()\textcolor{keyword}{ const}
00095 \textcolor{keyword}{        }\{
00096                 \textcolor{keywordflow}{return} m\_blockRowCount * m\_blockColCount * (ONE << 
      m\_blockTotalSize);
00097         \}
00098 
00099         \textcolor{keyword}{virtual} std::string get_index_method_name()\textcolor{keyword}{ const}
00100 \textcolor{keyword}{        }\{
00101                 \textcolor{keywordflow}{return} std::string(\textcolor{stringliteral}{"Block2DIndex"});
00102         \}
00103 
00104 \textcolor{comment}{/* specific method */}
00105 \textcolor{keyword}{public}:
00106         IndexType getBlockRowCount()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_blockRowCount; \}
00107         IndexType getBlockColCount()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_blockColCount; \}
00108         IndexType getBlockTotalSize()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} (ONE << m\_blockTotalSize);
       \}
00109         IndexType getBlockRowSize()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} (ONE << m\_blockRowSize); \}
00110         IndexType getBlockColSize()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} (ONE << m\_blockColSize); \}
00111 \};
00112 
00113 \textcolor{keyword}{class }ZOrderIndexIntuition : \textcolor{keyword}{public} IndexMethodInterface
00114 \{
00115 \textcolor{keyword}{private}:
00116         \textcolor{keyword}{const} IndexType ONE;
00117         IndexType *markEven;
00118         IndexType *markOdd;
00119         IndexType *markAll;
00120         IndexType m\_row, m\_col;
00121 
00122 \textcolor{keyword}{public}:
00127         ZOrderIndexIntuition(RowMajorIndexType row\_size, RowMajorIndexType 
      col\_size)
00128                 : ONE(1) , m\_row(row\_size), m\_col(col\_size)
00129         \{
00130                 init();
00131         \}
00132         \textcolor{keyword}{virtual} ~ZOrderIndexIntuition() \{ release(); \}
00133 
00134 \textcolor{keyword}{private}:
00135 
00136         \textcolor{comment}{/*}
00137 \textcolor{comment}{         *      @brief : init the markEven, markOdd, markAll array for boost
       the calculation}
00138 \textcolor{comment}{         */}
00139         \textcolor{keywordtype}{void} init() \{
00140                 \textcolor{keywordtype}{int} bitSize = 8*\textcolor{keyword}{sizeof}(IndexType);
00141                 markEven = \textcolor{keyword}{new} IndexType[bitSize];
00142                 markOdd = \textcolor{keyword}{new} IndexType[bitSize];
00143                 markAll = \textcolor{keyword}{new} IndexType[bitSize];
00144 
00145                 IndexType bitOdd = 1, bitEven = 2;
00146                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < (bitSize/2); ++i) \{
00147                         markOdd[i] = bitOdd;
00148                         markEven[i] = bitEven;
00149                         bitOdd <<= 2;
00150                         bitEven <<= 2;
00151                 \}
00152 
00153                 IndexType bitAll = 1;
00154                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < bitSize; ++i) \{
00155                         markAll[i] = bitAll;
00156                         bitAll <<= 1;
00157                 \}
00158         \}
00159 
00160         \textcolor{keywordtype}{void} release() \{
00161                 \textcolor{keyword}{delete} []markEven;
00162                 \textcolor{keyword}{delete} []markOdd;
00163                 \textcolor{keyword}{delete} []markAll;
00164         \}
00165 
00166 \textcolor{keyword}{public}:
00167         \textcolor{keyword}{virtual} IndexType get_row_result(RowMajorIndexType row\_index)\textcolor{keyword}{ const }\{
00168                 IndexType result = 0;
00169                 \textcolor{keywordtype}{int} loc = 0;
00170 
00171                 \textcolor{keywordflow}{while}(row\_index) \{
00172                         \textcolor{keywordflow}{if}(row\_index & ONE) \{
00173                                 result |= markEven[loc];
00174                         \}
00175                         row\_index >>= 1;
00176                         ++loc;
00177                 \}
00178                 \textcolor{keywordflow}{return} result;
00179         \}
00180 
00181         \textcolor{keyword}{virtual} IndexType get_index_by_row_result(IndexType row\_result, 
      RowMajorIndexType col\_index)\textcolor{keyword}{ const }\{
00182                 \textcolor{keywordtype}{int} loc = 0;
00183                 \textcolor{keywordflow}{while}(col\_index) \{
00184                         \textcolor{keywordflow}{if}(col\_index & ONE) \{
00185                                 row\_result |= markOdd[loc];
00186                         \}
00187                         col\_index >>= 1;
00188                         ++loc;
00189                 \}
00190                 \textcolor{keywordflow}{return} row\_result;
00191         \}
00192 
00193         \textcolor{keyword}{virtual} IndexType get_index(RowMajorIndexType row\_index, 
      RowMajorIndexType col\_index)\textcolor{keyword}{ const }\{
00194                 IndexType result = 0;
00195                 \textcolor{keywordtype}{int} loc = 0;
00196 
00197                 \textcolor{keywordflow}{while}(row\_index) \{
00198                         \textcolor{keywordflow}{if}(row\_index & ONE) \{
00199                                 result |= markEven[loc];
00200                         \}
00201                         row\_index >>= 1;
00202                         ++loc;
00203                 \}
00204 
00205                 loc = 0;
00206                 \textcolor{keywordflow}{while}(col\_index) \{
00207                         \textcolor{keywordflow}{if}(col\_index & ONE) \{
00208                                 result |= markOdd[loc];
00209                         \}
00210                         col\_index >>= 1;
00211                         ++loc;
00212                 \}
00213 
00214                 \textcolor{keywordflow}{return} result;
00215         \}
00216 
00217         \textcolor{keyword}{virtual} RowMajorPoint get_origin_index(IndexType index)\textcolor{keyword}{ const }\{
00218                 \textcolor{keywordtype}{size\_t} row = 0, col = 0;
00219                 IndexType loc = 0;
00220                 \textcolor{keywordflow}{while}(index) \{
00221                         \textcolor{keywordflow}{if}(index & ONE) col |= markAll[loc];
00222                         \textcolor{keywordflow}{if}((index >>= 1) & ONE) row |= markAll[loc];
00223                         index >>= 1;
00224                         ++loc;
00225                 \}
00226                 \textcolor{keywordflow}{return} RowMajorPoint(row, col);
00227         \}
00228 
00229         \textcolor{keyword}{virtual} IndexType get_max_index()\textcolor{keyword}{ const}
00230 \textcolor{keyword}{        }\{
00231                 \textcolor{keywordflow}{return} get_index(m\_row - 1, m\_col - 1);
00232         \}
00233 
00234         \textcolor{keyword}{virtual} std::string get_index_method_name()\textcolor{keyword}{ const}
00235 \textcolor{keyword}{        }\{
00236                 \textcolor{keywordflow}{return} std::string(\textcolor{stringliteral}{"ZOrderIndexIntuition"});
00237         \}
00238 \};
00239 
00240 \textcolor{keyword}{class }ZOrderIndex : \textcolor{keyword}{public} IndexMethodInterface
00241 \{
00242 \textcolor{keyword}{private}:
00243         \textcolor{keyword}{const} IndexType ONE;
00244         IndexType *markAll;
00245         IndexType m\_row, m\_col;
00246 
00247 \textcolor{keyword}{public}:
00252         ZOrderIndex(RowMajorIndexType row\_size, RowMajorIndexType col\_size)
00253                 : ONE(1) , m\_row(row\_size), m\_col(col\_size)
00254         \{
00255                 init();
00256         \}
00257         \textcolor{keyword}{virtual} ~ZOrderIndex() \{ release(); \}
00258 
00259 \textcolor{keyword}{private}:
00260 
00261         \textcolor{comment}{/*}
00262 \textcolor{comment}{         *      @brief : init the markEven, markOdd, markAll array for boost
       the calculation}
00263 \textcolor{comment}{         */}
00264         \textcolor{keywordtype}{void} init() \{
00265                 \textcolor{keywordtype}{int} bitSize = 8*\textcolor{keyword}{sizeof}(IndexType);
00266 
00267                 markAll = \textcolor{keyword}{new} IndexType[bitSize];
00268 
00269                 IndexType bitAll = 1;
00270                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < bitSize; ++i) \{
00271                         markAll[i] = bitAll;
00272                         bitAll <<= 1;
00273                 \}
00274         \}
00275 
00276         \textcolor{keywordtype}{void} release() \{
00277                 \textcolor{keyword}{delete} []markAll;
00278         \}
00279 
00280 \textcolor{keyword}{public}:
00281         \textcolor{keyword}{virtual} IndexType get_row_result(RowMajorIndexType row\_index)\textcolor{keyword}{ const }\{
00282                 \textcolor{keyword}{static} \textcolor{keyword}{const} IndexType B[] = \{0x5555555555555555, 
      0x3333333333333333,
00283                         0x0F0F0F0F0F0F0F0F, 0x00FF00FF00FF00FF, 
      0x0000FFFF0000FFFF\};
00284                 \textcolor{keyword}{static} \textcolor{keyword}{const} IndexType S[] = \{1, 2, 4, 8, 16\};
00285 
00286                 IndexType y = row\_index;
00287 
00288                 y = (y | (y << S[4])) & B[4];
00289                 y = (y | (y << S[3])) & B[3];
00290                 y = (y | (y << S[2])) & B[2];
00291                 y = (y | (y << S[1])) & B[1];
00292                 y = (y | (y << S[0])) & B[0];
00293 
00294                 \textcolor{keywordflow}{return} (y << 1);
00295         \}
00296 
00297         \textcolor{keyword}{virtual} IndexType get_index_by_row_result(IndexType row\_result, 
      RowMajorIndexType col\_index)\textcolor{keyword}{ const }\{
00298                 \textcolor{keyword}{static} \textcolor{keyword}{const} IndexType B[] = \{0x5555555555555555, 
      0x3333333333333333,
00299                         0x0F0F0F0F0F0F0F0F, 0x00FF00FF00FF00FF, 
      0x0000FFFF0000FFFF\};
00300                 \textcolor{keyword}{static} \textcolor{keyword}{const} IndexType S[] = \{1, 2, 4, 8, 16\};
00301 
00302                 IndexType x = col\_index;
00303 
00304                 x = (x | (x << S[4])) & B[4];
00305                 x = (x | (x << S[3])) & B[3];
00306                 x = (x | (x << S[2])) & B[2];
00307                 x = (x | (x << S[1])) & B[1];
00308                 x = (x | (x << S[0])) & B[0];
00309 
00310                 \textcolor{keywordflow}{return} (x | row\_result);
00311         \}
00312 
00313         \textcolor{keyword}{virtual} IndexType get_index(RowMajorIndexType row\_index, 
      RowMajorIndexType col\_index)\textcolor{keyword}{ const }\{
00314                 \textcolor{keyword}{static} \textcolor{keyword}{const} IndexType B[] = \{0x5555555555555555, 
      0x3333333333333333,
00315                         0x0F0F0F0F0F0F0F0F, 0x00FF00FF00FF00FF, 
      0x0000FFFF0000FFFF\};
00316                 \textcolor{keyword}{static} \textcolor{keyword}{const} IndexType S[] = \{1, 2, 4, 8, 16\};
00317 
00318                 \textcolor{comment}{//move the lower 32 bit of row\_index and col\_index into a
       interleaving bit result}
00319                 \textcolor{comment}{//must ensure the row\_index and col\_index is less than 2^32 -
       1, actually thus reasonable}
00320                 IndexType x = col\_index;
00321                 IndexType y = row\_index;
00322 
00323                 x = (x | (x << S[4])) & B[4];
00324                 x = (x | (x << S[3])) & B[3];
00325                 x = (x | (x << S[2])) & B[2];
00326                 x = (x | (x << S[1])) & B[1];
00327                 x = (x | (x << S[0])) & B[0];
00328 
00329                 y = (y | (y << S[4])) & B[4];
00330                 y = (y | (y << S[3])) & B[3];
00331                 y = (y | (y << S[2])) & B[2];
00332                 y = (y | (y << S[1])) & B[1];
00333                 y = (y | (y << S[0])) & B[0];
00334 
00335                 \textcolor{keywordflow}{return} (x | (y << 1));
00336         \}
00337 
00338         \textcolor{keyword}{virtual} RowMajorPoint get_origin_index(IndexType index)\textcolor{keyword}{ const }\{
00339                 \textcolor{keywordtype}{size\_t} row = 0, col = 0;
00340                 IndexType loc = 0;
00341                 \textcolor{keywordflow}{while}(index) \{
00342                         \textcolor{keywordflow}{if}(index & ONE) col |= markAll[loc];
00343                         \textcolor{keywordflow}{if}((index >>= 1) & ONE) row |= markAll[loc];
00344                         index >>= 1;
00345                         ++loc;
00346                 \}
00347                 \textcolor{keywordflow}{return} RowMajorPoint(row, col);
00348         \}
00349 
00350         \textcolor{keyword}{virtual} IndexType get_max_index()\textcolor{keyword}{ const}
00351 \textcolor{keyword}{        }\{
00352                 \textcolor{keywordflow}{return} get_index(m\_row - 1, m\_col - 1);
00353         \}
00354 
00355         \textcolor{keyword}{virtual} std::string get_index_method_name()\textcolor{keyword}{ const}
00356 \textcolor{keyword}{        }\{
00357                 \textcolor{keywordflow}{return} std::string(\textcolor{stringliteral}{"ZOrderIndex"});
00358         \}
00359 \};
00360 
00361 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
