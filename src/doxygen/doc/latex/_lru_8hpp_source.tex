\section{Lru.\-hpp}
\label{_lru_8hpp}\index{D\-:/\-Out\-\_\-\-Of\-\_\-\-Core\-\_\-\-Git/src/\-Lru.\-hpp@{D\-:/\-Out\-\_\-\-Of\-\_\-\-Core\-\_\-\-Git/src/\-Lru.\-hpp}}

\begin{DoxyCode}
00001 \textcolor{preprocessor}{#ifndef \_LRU\_HPP}
00002 \textcolor{preprocessor}{}\textcolor{preprocessor}{#define \_LRU\_HPP }
00003 \textcolor{preprocessor}{}
00004 \textcolor{preprocessor}{#include <list>}
00005 \textcolor{preprocessor}{#include <vector>}
00006 \textcolor{preprocessor}{#include <algorithm>}
00007 \textcolor{preprocessor}{#include <iostream>}
00008 \textcolor{preprocessor}{#include <fstream>}
00009 \textcolor{preprocessor}{#include <string>}
00010 
00011 \textcolor{preprocessor}{#include <boost/assert.hpp>}
00012 
00022 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>
00023 \textcolor{keyword}{class }ImageFileLRU
00024 \{
00025 \textcolor{keyword}{private}:
00026         \textcolor{keyword}{struct }ValueType
00027         \{
00028                 ValueType(std::string \_image\_file\_name, \textcolor{keywordtype}{int} \_file\_cell\_numbers)
00029                         : image\_file\_name(\_image\_file\_name), count(0)
00030                 \{
00031                         image\_data.resize(\_file\_cell\_numbers);
00032                 \}
00033 
00034                 \textcolor{keywordtype}{int} count;
00035                 std::string image\_file\_name;
00036                 std::vector<T> image\_data;
00037         \};
00038 
00039         \textcolor{keyword}{typedef} std::vector<ValueType> DataType;
00040 
00041 \textcolor{keyword}{public}:
00042 
00043 
00044         \textcolor{keywordtype}{void} init(\textcolor{keywordtype}{int} \_file\_cell\_numbers, \textcolor{keywordtype}{int} \_file\_cache\_numbers)
00045         \{
00046                 BOOST\_ASSERT(\_file\_cache\_numbers > 0);
00047                 file\_cell\_numbers = \_file\_cell\_numbers;
00048                 file\_cache\_numbers = \_file\_cache\_numbers;
00049                 current\_used = 0;
00050                 b\_data\_dirty.resize(file\_cache\_numbers, \textcolor{keyword}{false});
00051         \}
00052 
00058         ImageFileLRU(\textcolor{keywordtype}{int} \_file\_cell\_numbers = 0, \textcolor{keywordtype}{int} \_file\_cache\_numbers = 16) 
      \{
00059                 init(\_file\_cell\_numbers, \_file\_cache\_numbers);
00060         \}
00061 
00062         ~ImageFileLRU() \{
00063                 \textcolor{comment}{/* write back the dirty image */}
00064                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < lru\_data.size(); ++i) \{
00065                         \textcolor{keywordflow}{if}(b\_data\_dirty[i] == \textcolor{keyword}{true})
00066                                 write_back_data(i);
00067                 \}
00068         \}
00069 
00073         \textcolor{keywordtype}{bool} exists(\textcolor{keyword}{const} std::string &file\_name)\textcolor{keyword}{ const }\{
00074                 \textcolor{keywordflow}{for}(DataType::const\_iterator ite = lru\_data.cbegin(); ite != 
      lru\_data.cend(); ++ite) \{
00075                         \textcolor{keywordflow}{if}(ite->image\_file\_name == file\_name)
00076                                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00077                 \}
00078                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00079         \}
00080 
00084         \textcolor{keywordtype}{int} find(\textcolor{keyword}{const} std::string &file\_name)\textcolor{keyword}{ const }\{
00085                 \textcolor{keywordflow}{for}(DataType::const\_iterator ite = lru\_data.cbegin(); ite != 
      lru\_data.cend(); ++ite) \{
00086                         \textcolor{keywordflow}{if}(ite->image\_file\_name == file\_name)
00087                                 \textcolor{keywordflow}{return} (ite - lru\_data.cbegin());
00088                 \}
00089                 \textcolor{keywordflow}{return} npos;
00090         \}
00091 
00098         \textcolor{keywordtype}{int} put_into_lru(\textcolor{keyword}{const} std::string &file\_name) \{
00099                 \textcolor{keyword}{using namespace }std;
00100 
00101                 \textcolor{keywordtype}{int} index = find(file\_name);
00102 
00103                 \textcolor{comment}{/* value is in the lru caches, just return the index */}
00104                 \textcolor{keywordflow}{if}(index != npos)       \{
00105                         update_count(index);
00106                         \textcolor{keywordflow}{return} index;
00107                 \}
00108 
00109                 ifstream fin(file\_name, ios::in | ios::binary);
00110                 \textcolor{keywordflow}{if}(!fin.is\_open()) \{
00111                         cerr << \textcolor{stringliteral}{"can't open file "} << file\_name << endl;
00112                         \textcolor{keywordflow}{return} npos;
00113                 \}
00114 
00115                 \textcolor{comment}{/* the data cache is not full */}
00116                 \textcolor{keywordflow}{if}(current\_used < file\_cache\_numbers) \{
00117                         lru\_data.push\_back(ValueType(file\_name, 
      file\_cell\_numbers));
00118                         index = current\_used++;
00119                 \} \textcolor{keywordflow}{else} \{                \textcolor{comment}{/* remove one of the last not used data
       in cache */}
00120                         \textcolor{keywordtype}{int} max\_number = -1;
00121 
00122                         \textcolor{comment}{/* the last number count is the most not used data */}
00123                         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < file\_cache\_numbers; ++i) \{
00124                                 \textcolor{keywordflow}{if}(lru\_data[i].count > max\_number)      \{
00125                                         max\_number = lru\_data[i].count;
00126                                         index = i;
00127                                 \}
00128                         \}
00129 
00130                         \textcolor{keywordflow}{if}(!write_back_data(index)) \textcolor{keywordflow}{return} npos;
00131 
00132                         \textcolor{comment}{/* put the new data in the remove index, the data will
       be covered by the new data read from file */}
00133                         lru\_data[index].image\_file\_name = file\_name;
00134                 \}
00135 
00136                 \textcolor{comment}{/* read the data into cache */}
00137                 std::vector<T> &data = lru\_data[index].image\_data;
00138                 fin.read(reinterpret\_cast<char*>(&data[0]), file\_cell\_numbers*\textcolor{keyword}{
      sizeof}(T));
00139                 \textcolor{keywordflow}{if}(!fin.eof() && fin.fail()) \{
00140                         cerr << \textcolor{stringliteral}{"read image file "} << lru\_data[index].
      image\_file\_name << \textcolor{stringliteral}{" fails"} << endl;
00141                         \textcolor{keywordflow}{return} npos;
00142                 \}
00143 
00144                 fin.close();
00145                 update_count(index);
00146                 \textcolor{keywordflow}{return} index;
00147         \}
00148 
00153         \textcolor{keywordtype}{bool} write_back_data(\textcolor{keywordtype}{int} index) 
00154         \{
00155                 \textcolor{keyword}{using namespace }std;
00156 
00157                 \textcolor{comment}{/* if the data is dirty, then write it back to the file to
       update the data in the disk */}
00158                 \textcolor{keywordflow}{if}(b\_data\_dirty[index] == \textcolor{keyword}{true}) \{
00159                         ofstream fout(lru\_data[index].image\_file\_name, ios::out
       | ios::binary);
00160                         fout.write(reinterpret\_cast<char*>(&lru\_data[index].
      image\_data[0]), file\_cell\_numbers*\textcolor{keyword}{sizeof}(T));
00161 
00162                         \textcolor{keywordflow}{if}(fout.fail()) \{
00163                                 cerr << \textcolor{stringliteral}{"write image file "} << lru\_data[index].
      image\_file\_name << \textcolor{stringliteral}{" fails"} << endl;
00164                                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
00165                         \}
00166                         fout.close();
00167                 \}
00168 
00169                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};
00170         \}
00171 
00175         \textcolor{keywordtype}{void} update_count(\textcolor{keywordtype}{int} index) \{
00176                 BOOST\_ASSERT(index < lru\_data.size() && index >= 0);
00177                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < lru\_data.size(); ++i) \{
00178                         ++lru\_data[i].count;
00179                 \}
00180 
00181                 \textcolor{comment}{/* the most current used is index by 0 */}
00182                 lru\_data[index].count = 0;
00183         \}
00184 
00185         \textcolor{comment}{/*}
00186 \textcolor{comment}{         *      @brief get the index file cache's const data}
00187 \textcolor{comment}{         */}
00188         \textcolor{keyword}{const} std::vector<T>& get\_const\_data(\textcolor{keywordtype}{int} index)\textcolor{keyword}{ const }\{
00189                 BOOST\_ASSERT(index < lru\_data.size() && index >= 0);
00190                 \textcolor{keywordflow}{return} lru\_data[index].image\_data;
00191         \}
00192 
00193         \textcolor{comment}{/*}
00194 \textcolor{comment}{         *      @brief get the index file cache's data}
00195 \textcolor{comment}{         */}
00196         std::vector<T>& get\_data(\textcolor{keywordtype}{int} index) \{
00197                 BOOST\_ASSERT(index < lru\_data.size() && index >= 0);
00198                 
00199                 \textcolor{comment}{/* if get the image data by this function, then the data will
       be marked as dirty */}
00200                 b\_data\_dirty[index] = \textcolor{keyword}{true};
00201                 \textcolor{keywordflow}{return} lru\_data[index].image\_data;
00202         \}
00203 
00204 \textcolor{keyword}{public}:
00206         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} npos = -1;
00207 
00208 \textcolor{keyword}{private}:
00209         std::vector<ValueType> lru\_data;
00210         std::vector<bool> b\_data\_dirty;
00211         \textcolor{keywordtype}{size\_t} current\_used;
00212         \textcolor{keywordtype}{size\_t} file\_cache\_numbers;
00213         \textcolor{keywordtype}{size\_t} file\_cell\_numbers;
00214 \};
00215 
00216 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
